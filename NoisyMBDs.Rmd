---
title: "Environmental Noise and Ross-Macdonald Transmission Models"
author: "Karin Ebey, John Vinson and Kyle Dahlin"
date: "`r Sys.Date()`"
link-citations: yes
csl: proceedings-of-the-royal-society-b.csl
bibliography: bibliography.bib
output:
  pdf_document: 
    extra_dependencies: ["float"]
  html_document:
    df_print: paged
     keep_md: yes
---


```{r Libraries and settings, include = FALSE}
library(ggplot2)
library(tidyverse)
library(doParallel)
library(deSolve)
library(cowplot)
library(foreach) # for parallelization
library(ggridges) # for making ridgeplots
library(reshape2)
library(viridis)

# Parallelization settings
n_cores <- floor((detectCores() - 1) / 2)
registerDoParallel(cores = n_cores)

# Knitr settings (hides all chunk outputs besides figures and centers figures)
knitr::opts_chunk$set(
  echo = FALSE, cache = FALSE, warning = FALSE, message = FALSE, fig.pos = "H",
  out.extra = ""
)

# Settings for plotting and simulations ----

# Set this to TRUE to plot trajectories (which takes a lot of time and memory!)
plot_trajectories <- FALSE
```

```{r Functions, echo = FALSE}

# Deterministic model  ----
f <- function(t, x, parms) {
  with(as.list(c(parms, x)), {
    dH <- b * tHV * V * (NH - H) / NH - gH * H
    dV <- b * tVH * H * (NV - V) / NH - mV * V
    
    return(list(c(dH, dV)))
  })
}

# Stochastic model ----
f.stoc <- function(tMax, init_conds, parms) {
  with(as.list(c(parms, init_conds)), {
    dt <- 2^-8
    tseq <- seq(0, tMax, by = dt) # This ensures a fixed increment size determined by N
    N <- length(tseq)
    dW1 <- sqrt(dt) * rnorm(N, mean = 0, sd = 1) # H demographic stochasticity
    dW2 <- sqrt(dt) * rnorm(N, mean = 0, sd = 1) # V demographic stochasticity
    dW3 <- sqrt(dt) * rnorm(N, mean = 0, sd = 1) # Environmental stochasticity
    
    R <- 1
    Dt <- R * dt
    L <- N / R
    
    # Initial conditions (from init_conds)
    Htemp <- H
    Vtemp <- V
    
    Hout <- rep(0, L)
    Vout <- rep(0, L)
    
    tseq <- seq(0, tMax, length = L)
    
    for (i in 1:L) {
      
      W1inc <- sum(dW1[(R * (i - 1) + 1):(R * (i-1))])
      W2inc <- sum(dW2[(R * (i - 1) + 1):(R * (i-1))])
      W3inc <- sum(dW3[(R * (i - 1) + 1):(R * (i-1))])
      
      Htemp <- Htemp + (b * tHV * Vtemp * (NH - Htemp) / NH - gH * Htemp) * Dt +
        sqrt(b * tHV * Vtemp * (NH - Htemp) / NH + gH * Htemp) * W1inc +
        sigma * (alphab * Vtemp * tHV * (NH - Htemp) / NH) * W3inc
      
      Vtemp <- Vtemp + (b * tVH * Htemp * (NV - Vtemp) / NH - mV * Vtemp) * Dt +
        sqrt(b * tVH * Htemp * (NV - Vtemp) / NH + mV * Vtemp) * W2inc +
        sigma * (alphab * Htemp * tVH * (NV - Vtemp) / NH +
                   alphat * Htemp * b * (NV - Vtemp) / NH +
                   alpham * Vtemp
        ) * W3inc
      
      if (Htemp < 0 | is.nan(Htemp)) {
        Htemp <- 0
      }
      if (Vtemp < 0 | is.nan(Vtemp)) {
        Vtemp <- 0
      }
      
      Hout[i] <- Htemp
      Vout[i] <- Vtemp
    }
    
    return(data.frame(time = tseq, H = Hout, V = Vout))
  })
}

# Function: SDE solver ----
simulate.stoc <- function(parms.grid, y0.vec, tMax, nsim) {
  #     parms.key column gives a handle on which row of parms.grid was used to
  #     generate the trajectories
  int <- 1
  
  noise.out <- NULL
  
  noise.out.temp <- foreach(
    i = 1:dim(parms.grid)[1], j = 1:nsim, 
    int = icount(), .combine = "rbind",.packages = c("tidyverse"),
    # explicitly give 'foreach' the functions and data it needs
    .export = c("f.stoc")
  ) %dopar% {
    noise.out.temp <- NULL
    
    parms.use <- parms.grid[i, ]
    
    stoc.temp <- f.stoc(tMax, y0.vec, parms.use)
    # add simulation number as a column
    stoc.temp2 <- cbind(stoc.temp, int = as.factor(rep(int, dim(stoc.temp)[1])))
    # combine rows
    noise.out.temp <- rbind(noise.out.temp, stoc.temp2)
    
    
    # append parameter value key onto trajectory list
    # (instead of appending all parameters here, just do it at the end, we use
    #  the fact that parms.key is the row number of the parms.grid list)
    noise.out.parms <- mutate(noise.out.temp, parms.key = i)
    
    noise.out <- rbind(noise.out, noise.out.parms)
  }
  
  return(noise.out)
}

# Function: ONLY get statistics of stochastic trajectories ----
stats.stoc_fast <- function(parms.grid, y0.vec, tMax, nsim) {
  # the difference from stats.stoc is that trajectories don't get saved
  # we only get the statistics, then throw trajectory data out
  
  # Initialization
  stats.out <- NULL
  noise.out <- NULL
  int <- 1
  iter_grid <- expand_grid( i = 1:dim(parms.grid)[1], j = 1:nsim)
  
  # Generate statistics of the SDE trajectories
  stats.out <- foreach(
    k = 1:dim(iter_grid)[1], 
    int = icount(), .combine = "rbind", .packages = c("tidyverse"), .export = c("f.stoc")
  ) %dopar% {
    i = iter_grid$i[k]
    j = iter_grid$j[k]
    
    # Initialization
    stoc.temp <- NULL
    stats.temp <- NULL
    
    # Choose the parameter set
    parms.use <- parms.grid[i, ]
    # Generate SDE trajectories
    stoc.temp <- f.stoc(tMax, y0.vec, parms.use) %>% 
      # Only get the last 100 days of simulations (assuming trajectories are
      # pretty stable from this point onwards)
      #KE examine the whole time frame to explore if time to dying out varies with noise
      filter(time > tMax - 1095)
    
    # Calculate statistics
    # Maximum values along the trajectories
    max.V <- max(stoc.temp$V)
    max.H <- max(stoc.temp$H)
    # Minimum values along the trajectories
    min.V <- min(stoc.temp$V)
    min.H <- min(stoc.temp$H)
    # Mean values along the trajectories
    mean.V <- mean(stoc.temp$V)
    mean.H <- mean(stoc.temp$H)
    # Final values along the trajectories
    tail.H <- tail(stoc.temp$H)[1]
    tail.V <- tail(stoc.temp$V)[1]
    
    # Total epidemic die-out before final time point?
    if (tail.H == 0 & tail.V == 0) {
      ext <- 1
    } else {
      ext <- 0
    }
    
    # First time point of epidemic die-out
    zeroes.H <- which(stoc.temp$H == 0)
    zeroes.V <- which(stoc.temp$V == 0)
    coext <- intersect(zeroes.H, zeroes.V)
    if (length(coext) > 0) {
      first.ext.ind <- head(coext, 1)
      first.ext.time <- stoc.temp$time[first.ext.ind]
    } else {
      first.ext.time <- Inf
    }
    
    stats.temp <- cbind(
      parms.key = i, int = j,
      max.V = max.V, max.H = max.H,
      min.V = min.V, min.H = min.H,
      mean.V = mean.V, mean.H = mean.H,
      tail.H = tail.H, tail.V = tail.V,
      ext = ext, first.ext.time = first.ext.time
    )
    stats.temp
  }
  return(as.data.frame(stats.out))
}

# Function: Get statistics of stochastic trajectories ----
stats.stoc <- function(parms.grid, stoc.data) {
  stats.out <- NULL
  
  for (i in 1:dim(parms.grid)[1]) {
    parms.use <- parms.grid[i, ]
    
    stoc.sub <- plyr::match_df(stoc.data, parms.use, on = "sigma")
    
    for (j in unique(stoc.sub$int)) {
      stoc.sub.int <- subset(stoc.sub, int %in% j)
      
      # Maximum values along the trajectories
      max.V <- max(stoc.sub.int$V)
      max.H <- max(stoc.sub.int$H)
      # Minimum values along the trajectories
      min.V <- min(stoc.sub.int$V)
      min.H <- min(stoc.sub.int$H)
      # Mean values along the trajectories
      mean.V <- mean(stoc.sub.int$V)
      mean.H <- mean(stoc.sub.int$H)
      # Final values along the trajectories
      tail.H <- tail(stoc.sub.int$H)[1]
      tail.V <- tail(stoc.sub.int$V)[1]
      
      # Total epidemic die-out before final time point?
      if (tail.H == 0 & tail.V == 0) {
        ext <- 1
      } else {
        ext <- 0
      }
      
      # First time point of epidemic die-out
      zeroes.H <- which(stoc.sub.int$H == 0)
      zeroes.V <- which(stoc.sub.int$V == 0)
      coext <- intersect(zeroes.H, zeroes.V)
      if (length(coext) > 0) {
        first.ext.ind <- head(coext, 1)
        first.ext.time <- stoc.sub.int$time[first.ext.ind]
      } else {
        first.ext.time <- Inf
      }
      
      stats.temp <- cbind(parms.use,
                          int = j, max.V = max.V, max.H = max.H,
                          min.V = min.V, min.H = min.H, mean.V = mean.H,
                          mean.H = mean.H, tail.H = tail.H, tail.V = tail.V,
                          ext = ext, first.ext.time
      )
      
      stats.out <- rbind(stats.out, stats.temp)
    }
  }
  
  return(stats.out)
}
```

```{r Parameters, echo = FALSE}
# Parameters -------------------------
b <- 0.3 / 4.5 # biting rate # KD: R0 equals either 1.05 or 4.74
tHV <- 0.5 # transmission prob. from V to H
tVH <- 0.5 # transmission prob. from H to V
NH <- 1000 # host population size
NV <- 10000 # vector population size
gH <- 0.1 # recovery rate of hosts
mV <- 0.1 # mortality of vectors
#** Environmental noise ----
sigma <- seq(0, 1, length.out = 21) # strength of env. noise
alphab <- 1 # biting env. noise on/off
alphat <- 1 # trans. prob. env. noise on/off
alpham <- 1 # mort. env. noise on/off

R0 <- sqrt((b^2 * tHV * tVH * NV) / (NH * gH * mV))

Hstar <- max((NH * (b^2 * NV * tHV * tVH - NH * mV * gH)) / (b * tVH * (b * NV * tHV + NH * gH)), 1000)
Vstar <- max((b^2 * NV * tVH * tHV - NH * mV * gH) / (b * tHV * (b * tVH + mV)), 10000)

# Initial conditions------------------------------------------------------------
y0 <- c(H = 0, V = 10) # These are numbers of infected, so better to initialize at smaller values
tMax <- 10 * 365 # 500
dt <- 0.01
tspan <- seq(0.0, tMax, dt)
parms.vec <- c(b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV, gH = gH, mV = mV)
```
``` {r R0 calculator}
#solves for b-biting rate based on desired R0 value
tHV <- 0.5 # transmission prob. from V to H
tVH <- 0.5 # transmission prob. from H to V
NH <- 1000 # host population size
NV <- 10000# vector population size
gH <- 0.1 # recovery rate of hosts
mV <- 0.1 # mortality of vectors

R0=0.75
b=sqrt((R0^2*NH * gH * mV)/(tHV * tVH * NV))
b


#solves for tVH-transmission from hosts to mosquitos based on desired R0 value
b <- 0.3 #biting rate arbitrarily chosen baseline b to be 0.3, because that was used in O'Regan 2016 paper, and yeilds TVH values between 0 and 1
tHV <- 0.5 # transmission prob. from V to H
NH <- 1000 # host population size
NV <- 10000# vector population size
gH <- 0.1 # recovery rate of hosts
mV <- 0.1 # mortality of vectors

R0=c(0.75, 0.95, 1.05, 1.25, 2, 4, 6.5)
tVH=(R0^2*NH * gH * mV)/(b^2*tHV * NV)
tVH

```

## Introduction
Climate change is expected to lead to shifts in the risk of mosquito-borne disease outbreaks throughout the world. 
But it is unclear how increases in the variability of temperature and rainfall might impact these outbreaks. 
The goal of this project is to investigate how environmental and demographic noise affect key measures of the transmission of mosquito-borne diseases.

## Question

How does the strength of environmental noise influence the states of a simple Ross-Macdonald model?

Does the strength of environmental noise of different vector epidemiological traits (parameters) affect the critical states?  

## Models

### Simple Ross-Macdonald ODE

\begin{align}
\frac{dH}{dt} &= \frac{b \tau_{HV}}{N_H} V (N_H-H) - \gamma_H H\\
\frac{dV}{dt} &= \frac{b \tau_{VH}}{N_H} H (N_V-V) - \mu_V V
\end{align}

where, 

* $H$ is the number of infected hosts
* $V$ is the number of infected vectors

* $N_H$ is the total population/carrying capacity of hosts
* $N_V$ is the total population/carrying capacity of vectors

* $b$ is the per capita mosquito biting rate
* $\tau_{ij}$ is the probability of successful transmission from j to i
* $\frac{1}{\gamma_{H}}$ is the infectious period of the host
* $\frac{1}{\mu_{V}}$ is the lifespan/infectious period of vectors

The basic reproductive number of this model is:

\begin{equation}
R_0 = \sqrt{\frac{b^2 \tau_{HV} \tau_{VH} N_V}{N_H \mu_V \gamma_H}}
\end{equation}

For our chosen set of parameters, ${R}_0 =$ `r round(R0,3)`.

### Simple SDE

Following O'Regan et al. 2016, we can convert this system of ODEs to SDEs. We can incorporate demographic stochasticity with the following set of time varying equations:

\begin{align}
dH &= \left(\frac{b \tau_{HV}}{N_H} V (N_H-H) - \gamma_H H\right)dt + \sqrt{\frac{b \tau_{HV}}{N_H} V (N_H-H) + \gamma_H H} dW_1\\
dV &= \left(\frac{b \tau_{VH}}{N_H} H (N_V-V) - \mu_V V\right)dt + \sqrt{\frac{b \tau_{VH}}{N_H} H (N_V-V) + \mu_V V} dW_2
\end{align}

Here, the $dW_i$ are independent standard Wiener processes.


```{r Calculate trajectories, echo = FALSE}

# Deterministic trajectories----------------------------------------------------
ode.out <- data.frame(ode(y0, tspan, f, parms.vec))
ode.out <- cbind(ode.out, pH = ode.out$H / NH, pV = ode.out$V / NV)

ode.out.tall <- gather(ode.out, key = "state", value = "number", H:V)
ode.out.tall <- gather(ode.out.tall, key = "prev.state", value = "prev", pH:pV)

# Stochastic trajectories-------------------------------------------------------
#* No environmental noise ----
env.off.parms.vec <- as.list(parms.vec)
env.off.parms.vec$sigma <- 0 # turn off environmental noise

f.stoc.test <- f.stoc(tMax, y0, env.off.parms.vec)

f.stoc.test.tall <- gather(f.stoc.test, key = "state", value = "number", H:V)

#* With environmental noise ----
parms.grid <- expand.grid(
  b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV,
  gH = gH, mV = mV, sigma = sigma,
  alphab = alphab,
  alphat = alphat, alpham = alpham
) %>% 
  mutate(parms.key = row_number())

# parameters with demographic noise ONLY
parms.grid.dem.noise <- parms.grid %>% 
  mutate(alphab = 0) %>% 
  mutate(alphat = 0) %>% 
  mutate(alpham = 0)


# Calculate multiple trajectories ----
#  - only happens if the plot_trajectories boolean is true (I have this set at
#    the top of the document for now)
if (plot_trajectories) {
  nsim <- 10
  # Full trajectories (3 years)
  # stoc.set.out.long <- simulate.stoc(parms.grid, y0, 3 * tMax, nsim)
  # Shorter timespan (1 year)
  stoc.set.out <- simulate.stoc(parms.grid, y0, tMax, nsim)
  # stoc.set.out <- stoc.set.out.long %>%
  #   filter(time < tMax)
  
  # Append parameter values to the trajectory data frame
  stoc.set.out <- right_join(stoc.set.out, parms.grid)
}

# Calculate statistics of SDE trajectories ----
# Number of simulations to run
nsim <- 100
tMax <- 3 * 365
stoc.set.stats <- stats.stoc_fast(parms.grid, y0, tMax, nsim) %>%
  # Append parameter values to data frame
  right_join(., select(parms.grid, parms.key, sigma), by = "parms.key")

stoc.set.stats.dem.noise <- stats.stoc_fast(parms.grid.dem.noise, y0, tMax, nsim) %>%
  # Append parameter values to data frame
  right_join(., select(parms.grid, parms.key, sigma), by = "parms.key")


```

```{r Fig: No. infected (deterministic), out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:ODEnuminfected} The number infected over time in the ODE model. Both populations are initialized with 10 infected vectors.'}
ggplot(ode.out.tall) +
  geom_line(aes(x = time, y = number, color = state)) +
  theme_cowplot() +
  ggtitle("Number of infected")
```


```{r Fig: Prevalence (deterministic), out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:ODEprevalence} The prevalence of infections over time in the ODE model. Both populations are initialized with 10 infected vectors.'}
ggplot(ode.out.tall) +
  geom_line(aes(x = time, y = prev, color = prev.state)) +
  ylim(0, 1.0) +
  theme_cowplot() +
  ggtitle("Infection prevalence")
```


```{r Fig: No. infected (stochastic with no env. noise), out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:SDEnuminfected} The number of infections over time in the SDE model without demographic stochasticity. Both populations are initialized with 10 infected vectors.'}

ggplot(f.stoc.test.tall) +
  geom_line(aes(x = time, y = number, color = state)) +
  theme_cowplot() +
  ggtitle("Number of infected (no environmental stochasticity)")
```


```{r Fig: No. infected (w env. noise), out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:SDEenv_numinfected} The number of infected vectors over time in the SDE model with environmental stochasticity. Five trajectories are shown. Both populations are initialized with 10 infected vectors.'}

if (plot_trajectories) {
  ggplot(stoc.set.out) +
    geom_line(aes(
      x = time, y = V, color = as.factor(sigma),
      linetype = as.factor(int)
    ), alpha = 0.5) +
    theme_cowplot() +
    scale_colour_discrete(name = "Strength of\nenv. noise") +
    scale_linetype_manual(values = rep("solid", nsim)) +
    guides(linetype = "none") +
    ggtitle("Number of infected vectors")
}
```


```{r Fig. No. infected (w env. noise and long time span), warnings = FALSE, out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:SDEenv_numinfected_long} The number of infected vectors over time in the SDE model with environmental stochasticity. Five trajectories are shown. Looking over a longer time horizon to debug code. Both populations are initialized with 10 infected vectors.'}
# KD: I commented these out because they take a lot of resources both to
#     plot initially and within the actual figure
if (plot_trajectories) {
  ggplot(stoc.set.out.long) +
    geom_line(aes(
      x = time, y = V, # color = as.factor(sigma),
      linetype = as.factor(int)
    ), alpha = 0.5) +
    theme_cowplot() +
    # scale_colour_discrete(name = "Strength of\nenv. noise") +
    scale_linetype_manual(values = rep("solid", nsim)) +
    guides(linetype = "none") +
    ggtitle("Number of infected vectors")
}
```

Distribution of the final number of infected vectors
```{r Fig. Final No. infected vectors, warnings = FALSE, out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:SDE_final-size} Distribution of the number of infected vectors at the last time point of the SDE model with environmental stochasticity. Both populations are initialized with 10 infected vectors.'}
# Note: this shows the distributions of the final value from each simulation, 
#       not the distribution of the final N values of each simulation (which
#       may be what we actually want...)
stoc.set.stats %>%
  select(tail.V, sigma) %>%
  mutate(label = paste0("sigma = ", sigma)) %>% 
  ggplot(aes(x = sigma, y = tail.V, group = sigma)) +
  geom_boxplot() +
  ggtitle("Final infected vector population size")
```

Distribution of the final number of infected hosts
```{r Fig. Final No. infected hosts, warnings = FALSE, out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:SDE_final-size} Distribution of the number of infected hosts at the last time point of the SDE model with environmental stochasticity. Both populations are initialized with 10 infected vectors.'}
# Note: this shows the distributions of the final value from each simulation, 
#       not the distribution of the final N values of each simulation (which
#       may be what we actually want...)

stoc.set.stats %>%
  select(tail.H, sigma) %>%
  mutate(label = paste0("sigma = ", sigma)) %>% 
  ggplot(aes(x = sigma, y = tail.H, group = sigma)) +
  geom_boxplot() +
  ggtitle("Final infected host population size")
```

### Simulation Statistics 

Notes:
* when $\mathcal{R}_0 = 4.74$, we don't see any changes as $\sigma$ increases
```{r Fig: Stochastic trajectory statistics, echo = FALSE, out.width='100%', fig.height=10, fig.width=8, fig.align='center', fig.cap='\\label{fig:test_stats} Testing the stats function to make sure it returns correct values.'}

# More descriptive labels for statistics
stats_names <- c(
  "max.V" = "Max no. inf. vectors",
  "max.H" = "Max no. inf. hosts",
  "min.V" = "Min. no. inf. vectors",
  "min.H" = "Min. no. inf. hosts",
  "mean.V" = "Mean no. inf. vectirs",
  "mean.H" = "Mean no. inf. hosts",
  "tail.V" = "Final no. infected vectors",
  "tail.H" = "Final no. infected hosts",
  "ext" = "Epidemic died out?",
  "first.ext.time" = "1st extinction time"
)

stoc.set.stats.tall <- gather(stoc.set.stats,
                              key = "stat",
                              value = "value",
                              max.V:first.ext.time
) %>%
  select(-parms.key)
# Note: the regression lines don't really make sense for a couple of these,
#       so don't put too much stock in them. For example, the first stat is 
#       binary and the second can have a value of 'infinity', i.e. never extinct
stoc.set.stats.tall %>%
  group_by(stat) %>% 
  ggplot(aes(x = sigma, y = value)) +
  geom_point(aes(color = as.factor(int)), alpha = 0.2) +
  geom_smooth(method = 'lm') +
  theme_cowplot() +
  facet_wrap(~stat, scales = "free", labeller = as_labeller(stats_names)) +
  scale_colour_manual(values = rep("black", nsim)) +
  theme(legend.position = "none") +
  ggtitle("Stats Test")
```
```{r Fig: Stochastic trajectory statistics with demographic noise, echo = FALSE, out.width='100%', fig.height=10, fig.width=8, fig.align='center', fig.cap='\\label{fig:test_stats} Testing the stats function to make sure it returns correct values.'}

# More descriptive labels for statistics
stats_names <- c(
  "max.V" = "Max no. inf. vectors",
  "max.H" = "Max no. inf. hosts",
  "min.V" = "Min. no. inf. vectors",
  "min.H" = "Min. no. inf. hosts",
  "mean.V" = "Mean no. inf. vectors",
  "mean.H" = "Mean no. inf. hosts",
  "tail.V" = "Final no. infected vectors",
  "tail.H" = "Final no. infected hosts",
  "ext" = "Epidemic died out?",
  "first.ext.time" = "1st extinction time"
)

stoc.set.stats.tall <- gather(stoc.set.stats.dem.noise,
                              key = "stat",
                              value = "value",
                              max.V:first.ext.time
) %>%
  select(-parms.key)
# Note: the regression lines don't really make sense for a couple of these,
#       so don't put too much stock in them. For example, the first stat is 
#       binary and the second can have a value of 'infinity', i.e. never extinct
stoc.set.stats.tall %>%
  group_by(stat) %>% 
  ggplot(aes(x = sigma, y = value)) +
  geom_point(aes(color = as.factor(int)), alpha = 0.2) +
  geom_smooth(method = 'lm') +
  theme_cowplot() +
  facet_wrap(~stat, scales = "free", labeller = as_labeller(stats_names)) +
  scale_colour_manual(values = rep("black", nsim)) +
  theme(legend.position = "none") +
  ggtitle("Stats Test with demographic noise")
```


## Start of Karin's Tests
Question 1: How does the presence of demographic and demographic & environmental noise affect the probability of an outbreak dying out at different levels of R0?
```{r KE 1 Parameters, echo = FALSE}
ext_prob= matrix(c(1:12), ncol=4, byrow=TRUE)
colnames(ext_prob) = c('R0=0.75','R0=0.95', 'R0=1.05','R0=4')
rownames(ext_prob) <- c('Det.','Dem. Noise','Dem. & Env. Noise')
ext_prob[1,1] <- 1
ext_prob[1,2] <- 1
ext_prob[1,3] <- 0
ext_prob[1,4] <- 0



#KE Deterministic results with 3 R0 values
#Setting tMax=3 years based on preliminaries
#Selecting sigma=0.05 as baseline based on preliminaries
#R0=0.75
# Parameters 
b <- 0.04743416 # biting rate # KD: either 1.05 or 4.74
tHV <- 0.5 # transmission prob. from V to H
tVH <- 0.5 # transmission prob. from H to V
NH <- 1000 # host population size
NV <- 10000 # vector population size
gH <- 0.1 # recovery rate of hosts
mV <- 0.1 # mortality of vectors
# Environmental noise 
sigma <- 0.05 # strength of env. noise
alphab <- 1 # biting env. noise off
alphat <- 1 # trans. prob. env. noise off
alpham <- 1 # mort. env. noise off

R0 <- sqrt((b^2 * tHV * tVH * NV) / (NH * gH * mV))

Hstar <- max((NH * (b^2 * NV * tHV * tVH - NH * mV * gH)) / (b * tVH * (b * NV * tHV + NH * gH)), 100)
Vstar <- max((b^2 * NV * tVH * tHV - NH * mV * gH) / (b * tHV * (b * tVH + mV)), 1000)

# Initial conditions------------------------------------------------------------
y0 <- c(H = 0, V = 10) # These are numbers of infected, so better to initialize at smaller values
tMax <- 10 * 365 # 500
dt <- 1
tspan <- seq(0.0, tMax, dt)
parms.vec <- c(b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV, gH = gH, mV = mV)

# Deterministic trajectories
ode.out <- data.frame(ode(y0, tspan, f, parms.vec))
ode.out <- cbind(ode.out, pH = ode.out$H / NH, pV = ode.out$V / NV)

ode.out.tall <- gather(ode.out, key = "state", value = "number", H:V)
ode.out.tall <- gather(ode.out.tall, key = "prev.state", value = "prev", pH:pV)

# Only Demographic noise 
env.off.parms.vec <- as.list(parms.vec)
env.off.parms.vec$sigma <- 0 # turn off environmental noise

f.stoc.test <- f.stoc(tMax, y0, env.off.parms.vec)

f.stoc.test.tall <- gather(f.stoc.test, key = "state", value = "number", H:V)

#Demographic and Environmental noise ----
env.on.parms.vec <- as.list(parms.vec)
env.on.parms.vec$sigma <- sigma # turn on environmental noise to 0.1 level

f.stoc.test_1 <- f.stoc(tMax, y0, env.off.parms.vec)

f.stoc.test.tall_1 <- gather(f.stoc.test_1, key = "state", value = "number", H:V)

# Calculate statistics of SDE trajectories ----
# Number of simulations to run
nsim <- 100
tMax <- 10 * 365
parms.grid <- expand.grid(
  b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV,
  gH = gH, mV = mV, sigma = sigma,
  alphab = alphab,
  alphat = alphat, alpham = alpham
) %>%
  mutate(parms.key = row_number())

# parameters with demographic noise ONLY
parms.grid.dem.noise <- parms.grid %>% 
  mutate(alphab = 0) %>% 
  mutate(alphat = 0) %>% 
  mutate(alpham = 0) %>%
  mutate(sigma = 0)

stoc.set.stats.dem.noise <- stats.stoc_fast(parms.grid.dem.noise, y0, tMax, nsim) %>%
  # Append parameter values to data frame
  right_join(., select(parms.grid.dem.noise, parms.key, sigma), by = "parms.key")
#calculate the probability of disease dying out out of 100 simulations
ext_prob[2,1] <- sum(stoc.set.stats.dem.noise$ext)/nsim

stoc.set.stats.demenv.noise <- stats.stoc_fast(parms.grid, y0, tMax, nsim) %>%
  # Append parameter values to data frame
  right_join(., select(parms.grid, parms.key, sigma), by = "parms.key")
#calculate the probability of disease dying out out of 100 simulations 
ext_prob[3,1] <- sum(stoc.set.stats.demenv.noise$ext)/nsim

```
```{r Fig: No. infected (deterministic), out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:ODEnuminfected} The number infected over time in the ODE model with R0=0.75. Both populations are initialized with 10 infected vectors.'}
ggplot(ode.out.tall) +
  geom_line(aes(x = time, y = number, color = state)) +
  theme_cowplot() +
  ggtitle("Number of infected R0=0.75")
```
```{r Fig: No. infected (stochastic with only demographic noise), out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:SDEnuminfected} The number of infections over time in the SDE model with only demographic stochasticity and R0=0.75. Both populations are initialized with 10 infected vectors.'}

ggplot(f.stoc.test.tall) +
  geom_line(aes(x = time, y = number, color = state)) +
  theme_cowplot() +
  ggtitle("Number of infected with dem. noise R0=0.75")
```
```{r Fig: No. infected (stochastic with demographic and environmental noise), out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:SDEnuminfected} The number of infections over time in the SDE model with demographic and environmental stochasticity (sigma=0.05) and R0=0.75. Both populations are initialized with 10 infected vectors.'}

ggplot(f.stoc.test.tall_1) +
  geom_line(aes(x = time, y = number, color = state)) +
  theme_cowplot() +
  ggtitle("Number of infected with dem. & env. noise R0=0.75")
```
```{r Parameters, echo = FALSE}
#KE Deterministic results with 3 R0 values
#R0=0.95
# Parameters 
b <- 0.06008328 # biting rate # KD: either 1.05 or 4.74
tHV <- 0.5 # transmission prob. from V to H
tVH <- 0.5 # transmission prob. from H to V
NH <- 1000 # host population size
NV <- 10000 # vector population size
gH <- 0.1 # recovery rate of hosts
mV <- 0.1 # mortality of vectors
# Environmental noise 
sigma <- 0.05 # strength of env. noise
alphab <- 1 # biting env. noise off
alphat <- 1 # trans. prob. env. noise off
alpham <- 1 # mort. env. noise off

R0 <- sqrt((b^2 * tHV * tVH * NV) / (NH * gH * mV))

Hstar <- max((NH * (b^2 * NV * tHV * tVH - NH * mV * gH)) / (b * tVH * (b * NV * tHV + NH * gH)), 100)
Vstar <- max((b^2 * NV * tVH * tHV - NH * mV * gH) / (b * tHV * (b * tVH + mV)), 1000)

# Initial conditions
y0 <- c(H = 0, V = 10) # These are numbers of infected, so better to initialize at smaller values
tMax <- 3 * 365 # 500
dt <- 0.01
tspan <- seq(0.0, tMax, dt)
parms.vec <- c(b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV, gH = gH, mV = mV)

# Deterministic trajectories
ode.out <- data.frame(ode(y0, tspan, f, parms.vec))
ode.out <- cbind(ode.out, pH = ode.out$H / NH, pV = ode.out$V / NV)

ode.out.tall <- gather(ode.out, key = "state", value = "number", H:V)
ode.out.tall <- gather(ode.out.tall, key = "prev.state", value = "prev", pH:pV)

# Only Demographic noise 
env.off.parms.vec <- as.list(parms.vec)
env.off.parms.vec$sigma <- 0 # turn off environmental noise

f.stoc.test <- f.stoc(tMax, y0, env.off.parms.vec)

f.stoc.test.tall <- gather(f.stoc.test, key = "state", value = "number", H:V)

#Demographic and Environmental noise 
env.on.parms.vec <- as.list(parms.vec)
env.on.parms.vec$sigma <- sigma # turn on environmental noise to 0.1 level

f.stoc.test_1 <- f.stoc(tMax, y0, env.off.parms.vec)

f.stoc.test.tall_1 <- gather(f.stoc.test_1, key = "state", value = "number", H:V)

# Calculate statistics of SDE trajectories ----
# Number of simulations to run
nsim <- 100
tMax <- 3 * 365
parms.grid <- expand.grid(
  b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV,
  gH = gH, mV = mV, sigma = sigma,
  alphab = alphab,
  alphat = alphat, alpham = alpham
) %>%
  mutate(parms.key = row_number())

# parameters with demographic noise ONLY
parms.grid.dem.noise <- parms.grid %>% 
  mutate(alphab = 0) %>% 
  mutate(alphat = 0) %>% 
  mutate(alpham = 0) %>%
  mutate(sigma = 0)

stoc.set.stats.dem.noise <- stats.stoc_fast(parms.grid.dem.noise, y0, tMax, nsim) %>%
  # Append parameter values to data frame
  right_join(., select(parms.grid.dem.noise, parms.key, sigma), by = "parms.key")
#calculate the probability of disease dying out out of 100 simulations
ext_prob[2,2] <- sum(stoc.set.stats.dem.noise$ext)/nsim

stoc.set.stats.demenv.noise <- stats.stoc_fast(parms.grid, y0, tMax, nsim) %>%
  # Append parameter values to data frame
  right_join(., select(parms.grid, parms.key, sigma), by = "parms.key")
#calculate the probability of disease dying out out of 100 simulations 
ext_prob[3,2] <- sum(stoc.set.stats.demenv.noise$ext)/nsim

```
```{r Fig: No. infected (deterministic), out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:ODEnuminfected} The number infected over time in the ODE model with R0=0.95. Both populations are initialized with 10 infected vectors.'}
ggplot(ode.out.tall) +
  geom_line(aes(x = time, y = number, color = state)) +
  theme_cowplot() +
  ggtitle("Number of infected R0=0.95")
```
```{r Fig: No. infected (stochastic with only demographic noise), out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:SDEnuminfected} The number of infections over time in the SDE model with only demographic stochasticity and R0=0.95. Both populations are initialized with 10 infected vectors.'}

ggplot(f.stoc.test.tall) +
  geom_line(aes(x = time, y = number, color = state)) +
  theme_cowplot() +
  ggtitle("Number of infected with dem. noise R0=0.95")
```
```{r Fig: No. infected (stochastic with demographic and environmental noise), out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:SDEnuminfected} The number of infections over time in the SDE model with demographic and environmental stochasticity (sigma=0.05)and R0=0.95. Both populations are initialized with 10 infected vectors.'}

ggplot(f.stoc.test.tall_1) +
  geom_line(aes(x = time, y = number, color = state)) +
  theme_cowplot() +
  ggtitle("Number of infected with dem. & env. noise R0=0.95")
```





```{r Parameters, echo = FALSE}
#KE Deterministic results with 3 R0 values
#R0=1.05
# Parameters 
b <- 0.06640783 # biting rate # KD: either 1.05 or 4.74
tHV <- 0.5 # transmission prob. from V to H
tVH <- 0.5 # transmission prob. from H to V
NH <- 1000 # host population size
NV <- 10000 # vector population size
gH <- 0.1 # recovery rate of hosts
mV <- 0.1 # mortality of vectors
# Environmental noise 
sigma <- 0.05 # strength of env. noise
alphab <- 1 # biting env. noise off
alphat <- 1 # trans. prob. env. noise off
alpham <- 1 # mort. env. noise off

R0 <- sqrt((b^2 * tHV * tVH * NV) / (NH * gH * mV))

Hstar <- max((NH * (b^2 * NV * tHV * tVH - NH * mV * gH)) / (b * tVH * (b * NV * tHV + NH * gH)), 100)
Vstar <- max((b^2 * NV * tVH * tHV - NH * mV * gH) / (b * tHV * (b * tVH + mV)), 1000)

# Initial conditions
y0 <- c(H = 0, V = 10) # These are numbers of infected, so better to initialize at smaller values
tMax <- 3 * 365 # 500
dt <- 0.01
tspan <- seq(0.0, tMax, dt)
parms.vec <- c(b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV, gH = gH, mV = mV)

# Deterministic trajectories
ode.out <- data.frame(ode(y0, tspan, f, parms.vec))
ode.out <- cbind(ode.out, pH = ode.out$H / NH, pV = ode.out$V / NV)

ode.out.tall <- gather(ode.out, key = "state", value = "number", H:V)
ode.out.tall <- gather(ode.out.tall, key = "prev.state", value = "prev", pH:pV)

# Only Demographic noise 
env.off.parms.vec <- as.list(parms.vec)
env.off.parms.vec$sigma <- 0 # turn off environmental noise

f.stoc.test <- f.stoc(tMax, y0, env.off.parms.vec)

f.stoc.test.tall <- gather(f.stoc.test, key = "state", value = "number", H:V)

#Demographic and Environmental noise 
env.on.parms.vec <- as.list(parms.vec)
env.on.parms.vec$sigma <- sigma # turn on environmental noise to 0.1 level

f.stoc.test_1 <- f.stoc(tMax, y0, env.off.parms.vec)

f.stoc.test.tall_1 <- gather(f.stoc.test_1, key = "state", value = "number", H:V)

# Calculate statistics of SDE trajectories ----
# Number of simulations to run
nsim <- 100
tMax <- 3 * 365
parms.grid <- expand.grid(
  b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV,
  gH = gH, mV = mV, sigma = sigma,
  alphab = alphab,
  alphat = alphat, alpham = alpham
) %>%
  mutate(parms.key = row_number())

# parameters with demographic noise ONLY
parms.grid.dem.noise <- parms.grid %>% 
  mutate(alphab = 0) %>% 
  mutate(alphat = 0) %>% 
  mutate(alpham = 0) %>%
  mutate(sigma = 0)

stoc.set.stats.dem.noise <- stats.stoc_fast(parms.grid.dem.noise, y0, tMax, nsim) %>%
  # Append parameter values to data frame
  right_join(., select(parms.grid.dem.noise, parms.key, sigma), by = "parms.key")
#calculate the probability of disease dying out out of 100 simulations
ext_prob[2,3] <- sum(stoc.set.stats.dem.noise$ext)/nsim

stoc.set.stats.demenv.noise <- stats.stoc_fast(parms.grid, y0, tMax, nsim) %>%
  # Append parameter values to data frame
  right_join(., select(parms.grid, parms.key, sigma), by = "parms.key")
#calculate the probability of disease dying out out of 100 simulations 
ext_prob[3,3] <- sum(stoc.set.stats.demenv.noise$ext)/nsim
```
```{r Fig: No. infected (deterministic), out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:ODEnuminfected} The number infected over time in the ODE model with R0=1.05. Both populations are initialized with 10 infected vectors.'}
ggplot(ode.out.tall) +
  geom_line(aes(x = time, y = number, color = state)) +
  theme_cowplot() +
  ggtitle("Number of infected R0=1.05")
```
```{r Fig: No. infected (stochastic with only demographic noise), out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:SDEnuminfected} The number of infections over time in the SDE model with only demographic stochasticity and R0=1.05. Both populations are initialized with 10 infected vectors.'}

ggplot(f.stoc.test.tall) +
  geom_line(aes(x = time, y = number, color = state)) +
  theme_cowplot() +
  ggtitle("Number of infected with dem. noise R0=1.05")
```
```{r Fig: No. infected (stochastic with demographic and environmental noise), out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:SDEnuminfected} The number of infections over time in the SDE model with demographic and environmental stochasticity (sigma=0.05)and R0=1.05. Both populations are initialized with 10 infected vectors.'}

ggplot(f.stoc.test.tall_1) +
  geom_line(aes(x = time, y = number, color = state)) +
  theme_cowplot() +
  ggtitle("Number of infected with dem. & env. noise R0=1.05")
```
```{r Parameters, echo = FALSE}
#KE Deterministic results with 3 R0 values
#R0=4
# Parameters 
b <- 0.2529822 # biting rate # KD: either 1.05 or 4.74
tHV <- 0.5 # transmission prob. from V to H
tVH <- 0.5 # transmission prob. from H to V
NH <- 1000 # host population size
NV <- 10000 # vector population size
gH <- 0.1 # recovery rate of hosts
mV <- 0.1 # mortality of vectors
#** Environmental noise 
sigma <- 0.05 # strength of env. noise
alphab <- 1 # biting env. noise off
alphat <- 1 # trans. prob. env. noise off
alpham <- 1 # mort. env. noise off

R0 <- sqrt((b^2 * tHV * tVH * NV) / (NH * gH * mV))

Hstar <- max((NH * (b^2 * NV * tHV * tVH - NH * mV * gH)) / (b * tVH * (b * NV * tHV + NH * gH)), 100)
Vstar <- max((b^2 * NV * tVH * tHV - NH * mV * gH) / (b * tHV * (b * tVH + mV)), 1000)

# Initial conditions
y0 <- c(H = 0, V = 10) # These are numbers of infected, so better to initialize at smaller values
tMax <- 3 * 365 # 500
dt <- 0.01
tspan <- seq(0.0, tMax, dt)
parms.vec <- c(b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV, gH = gH, mV = mV)

# Deterministic trajectories----------------------------------------------------
ode.out <- data.frame(ode(y0, tspan, f, parms.vec))
ode.out <- cbind(ode.out, pH = ode.out$H / NH, pV = ode.out$V / NV)

ode.out.tall <- gather(ode.out, key = "state", value = "number", H:V)
ode.out.tall <- gather(ode.out.tall, key = "prev.state", value = "prev", pH:pV)

#* Only Demographic noise 
env.off.parms.vec <- as.list(parms.vec)
env.off.parms.vec$sigma <- 0 # turn off environmental noise

f.stoc.test <- f.stoc(tMax, y0, env.off.parms.vec)

f.stoc.test.tall <- gather(f.stoc.test, key = "state", value = "number", H:V)

#Demographic and Environmental noise 
env.on.parms.vec <- as.list(parms.vec)
env.on.parms.vec$sigma <- sigma # turn on environmental noise 

f.stoc.test_1 <- f.stoc(tMax, y0, env.off.parms.vec)

f.stoc.test.tall_1 <- gather(f.stoc.test_1, key = "state", value = "number", H:V)

# Calculate statistics of SDE trajectories ----
# Number of simulations to run
nsim <- 100
tMax <- 3 * 365
parms.grid <- expand.grid(
  b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV,
  gH = gH, mV = mV, sigma = sigma,
  alphab = alphab,
  alphat = alphat, alpham = alpham
) %>%
  mutate(parms.key = row_number())

# parameters with demographic noise ONLY
parms.grid.dem.noise <- parms.grid %>% 
  mutate(alphab = 0) %>% 
  mutate(alphat = 0) %>% 
  mutate(alpham = 0) %>%
  mutate(sigma = 0)

stoc.set.stats.dem.noise <- stats.stoc_fast(parms.grid.dem.noise, y0, tMax, nsim) %>%
  # Append parameter values to data frame
  right_join(., select(parms.grid.dem.noise, parms.key, sigma), by = "parms.key")
#calculate the probability of disease dying out out of 100 simulations
ext_prob[2,4] <- sum(stoc.set.stats.dem.noise$ext)/nsim

stoc.set.stats.demenv.noise <- stats.stoc_fast(parms.grid, y0, tMax, nsim) %>%
  # Append parameter values to data frame
  right_join(., select(parms.grid, parms.key, sigma), by = "parms.key")
#calculate the probability of disease dying out out of 100 simulations 
ext_prob[3,4] <- sum(stoc.set.stats.demenv.noise$ext)/nsim

```
```{r Fig: No. infected (deterministic), out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:ODEnuminfected} The number infected over time in the ODE model with R0=4. Both populations are initialized with 10 infected vectors.'}
ggplot(ode.out.tall) +
  geom_line(aes(x = time, y = number, color = state)) +
  theme_cowplot() +
  ggtitle("Number of infected R0=4")
```
```{r Fig: No. infected (stochastic with only demographic noise), out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:SDEnuminfected} The number of infections over time in the SDE model with only demographic stochasticity and R0=4. Both populations are initialized with 10 infected vectors.'}

ggplot(f.stoc.test.tall) +
  geom_line(aes(x = time, y = number, color = state)) +
  theme_cowplot() +
  ggtitle("Number of infected with dem. noise R0=4")
```
```{r Fig: No. infected (stochastic with demographic and environmental noise), out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:SDEnuminfected} The number of infections over time in the SDE model with demographic and environmental stochasticity and R0=4. Both populations are initialized with 10 infected vectors.'}

ggplot(f.stoc.test.tall_1) +
  geom_line(aes(x = time, y = number, color = state)) +
  theme_cowplot() +
  ggtitle("Number of infected with dem. & env. noise R0=4")
```
```{r Table: Probability of outbreak dying out, out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:ODEnuminfected} The probability of the outbreak dying out in deterministic, with demographic noise, and with demographic & environmental (sigma=0.1) noise based on 100 runs of simulation at three levels of R0.'}
ext_prob_table <- as.table(ext_prob)
ext_prob_table
```

##Question 2. How does the magnitude of strength of environmental noise impact the dynamics of mosquito borne disease outbreak?
```{r Parameters, echo = FALSE}
b <-  0.2529822 # biting rate # R0=4
tHV <- 0.5 # transmission prob. from V to H
tVH <- 0.5 # transmission prob. from H to V
NH <- 1000 # host population size
NV <- 10000 # vector population size
gH <- 0.1 # recovery rate of hosts
mV <- 0.1 # mortality of vectors
#** Environmental noise 
sigma <- seq(0, 0.1, length.out = 11) # strength of env. noise
alphab <- 1 # biting env. noise off
alphat <- 1 # trans. prob. env. noise off
alpham <- 1 # mort. env. noise off

R0 <- sqrt((b^2 * tHV * tVH * NV) / (NH * gH * mV))

Hstar <- max((NH * (b^2 * NV * tHV * tVH - NH * mV * gH)) / (b * tVH * (b * NV * tHV + NH * gH)), 100)
Vstar <- max((b^2 * NV * tVH * tHV - NH * mV * gH) / (b * tHV * (b * tVH + mV)), 1000)

# Initial conditions
y0 <- c(H = 0, V = 10) # These are numbers of infected, so better to initialize at smaller values
tMax <- 3 * 365 # 500
dt <- 0.01
tspan <- seq(0.0, tMax, dt)
parms.vec <- c(b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV, gH = gH, mV = mV)


# Calculate statistics of SDE trajectories ----
# Number of simulations to run
nsim <- 100
tMax <- 3 * 365
parms.grid <- expand.grid(
  b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV,
  gH = gH, mV = mV, sigma = sigma,
  alphab = alphab,
  alphat = alphat, alpham = alpham
) %>%
  mutate(parms.key = row_number())

stoc.set.stats.env.noise <- stats.stoc_fast(parms.grid, y0, tMax, nsim) %>%
  # Append parameter values to data frame
  right_join(., select(parms.grid, parms.key, sigma), by = "parms.key")

```
```{r Fig: Relationship between magnitude of environmental noise and number of hosts infected, out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:SDEnuminfected} The mean number of hosts infected at different levels of environmental noise in the SDE model with demographic and environmental stochasticity at R0=4. Both populations are initialized with 10 infected vectors.'}

ggplot(stoc.set.stats.env.noise, aes(x = sigma, y = mean.H, group = sigma)) +
  geom_boxplot() +
  ggtitle("Mean infected host population size R0=4") +geom_smooth(method='lm', se=FALSE, color="black", aes(group=1))+
  theme_cowplot() 
```
```{r Fig: Relationship between magnitude of environmental noise and number of vectors infected, out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:SDEnuminfected} The mean number of vectors infected at different levels of environmental noise in the SDE model with demographic and environmental stochasticity at R0=4. Both populations are initialized with 10 infected vectors.'}

ggplot(stoc.set.stats.env.noise, aes(x = sigma, y = mean.V, group = sigma)) +
  geom_boxplot() +
  ggtitle("Mean infected vector population size R0=4") +geom_smooth(method='lm', se=FALSE, color="black", aes(group=1))+
  theme_cowplot() 
```

```{r Parameters, echo = FALSE}
b <- 0.06640783 # biting rate # R0=1.05
tHV <- 0.5 # transmission prob. from V to H
tVH <- 0.5 # transmission prob. from H to V
NH <- 1000 # host population size
NV <- 10000 # vector population size
gH <- 0.1 # recovery rate of hosts
mV <- 0.1 # mortality of vectors
#** Environmental noise ----
sigma <- seq(0, 0.1, length.out = 11) # strength of env. noise
alphab <- 1 # biting env. noise off
alphat <- 1 # trans. prob. env. noise off
alpham <- 1 # mort. env. noise off

R0 <- sqrt((b^2 * tHV * tVH * NV) / (NH * gH * mV))

Hstar <- max((NH * (b^2 * NV * tHV * tVH - NH * mV * gH)) / (b * tVH * (b * NV * tHV + NH * gH)), 100)
Vstar <- max((b^2 * NV * tVH * tHV - NH * mV * gH) / (b * tHV * (b * tVH + mV)), 1000)

# Initial conditions------------------------------------------------------------
y0 <- c(H = 0, V = 10) # These are numbers of infected, so better to initialize at smaller values
tMax <- 3 * 365 # 500
dt <- 0.01
tspan <- seq(0.0, tMax, dt)
parms.vec <- c(b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV, gH = gH, mV = mV)


# Calculate statistics of SDE trajectories ----
# Number of simulations to run
nsim <- 100
tMax <- 3 * 365
parms.grid <- expand.grid(
  b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV,
  gH = gH, mV = mV, sigma = sigma,
  alphab = alphab,
  alphat = alphat, alpham = alpham
) %>%
  mutate(parms.key = row_number())

stoc.set.stats.env.noise <- stats.stoc_fast(parms.grid, y0, tMax, nsim) %>%
  # Append parameter values to data frame
  right_join(., select(parms.grid, parms.key, sigma), by = "parms.key")

```
```{r Fig: Relationship between magnitude of environmental noise and number of hosts infected, out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:SDEnuminfected} The mean number of hosts infected at different levels of environmental noise in the SDE model with demographic and environmental stochasticity at R0=1.05. Both populations are initialized with 10 infected vectors.'}

ggplot(stoc.set.stats.env.noise, aes(x = sigma, y = mean.H, group = sigma)) +
  geom_boxplot() +
  ggtitle("Mean infected host population size R0=1.05") + geom_smooth(method='lm', se=FALSE, color="black", aes(group=1))+
  theme_cowplot() 
```
```{r Fig: Relationship between magnitude of environmental noise and number of vectors infected, out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:SDEnuminfected} The mean number of vectors infected at different levels of environmental noise in the SDE model with demographic and environmental stochasticity at R0=1.05. Both populations are initialized with 10 infected vectors.'}

ggplot(stoc.set.stats.env.noise, aes(x = sigma, y = mean.V, group = sigma)) +
  geom_boxplot() +
  ggtitle("Mean infected vector population size R0=1.05") +geom_smooth(method='lm', se=FALSE, color="black", aes(group=1))+
  theme_cowplot() 
```

```{r R0 and Sigma expo, echo = FALSE}
b <- c(0.04743416, 0.06008328, 0.06640783, 0.12649111, 0.25298221) # biting rate # R0=0.75; 0.95; 1.05; 4
tHV <- 0.5 # transmission prob. from V to H
tVH <- 0.5 # transmission prob. from H to V
NH <- 1000 # host population size
NV <- 10000 # vector population size
gH <- 0.1 # recovery rate of hosts
mV <- 0.1 # mortality of vectors
#** Environmental noise ----
sigma <- seq(0, 0.1, length.out = 11) # strength of env. noise
alphab <- 1 # biting env. noise off
alphat <- 1 # trans. prob. env. noise off
alpham <- 1 # mort. env. noise off

R0 <- sqrt((b^2 * tHV * tVH * NV) / (NH * gH * mV))

Hstar <- max((NH * (b^2 * NV * tHV * tVH - NH * mV * gH)) / (b * tVH * (b * NV * tHV + NH * gH)), 100)
Vstar <- max((b^2 * NV * tVH * tHV - NH * mV * gH) / (b * tHV * (b * tVH + mV)), 1000)
y0 <- c(H = 0, V = 10) # These are numbers of infected, so better to initialize at smaller values
tMax <- 3 * 365 # 500
dt <- 0.01
tspan <- seq(0.0, tMax, dt)
parms.vec <- c(b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV, gH = gH, mV = mV)


# Calculate statistics of SDE trajectories ----
# Number of simulations to run
nsim <- 50
tMax <- 3 * 365
parms.grid <- expand.grid(
  b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV,
  gH = gH, mV = mV, sigma = sigma,
  alphab = alphab,
  alphat = alphat, alpham = alpham
) %>%
  mutate(parms.key = row_number())

stoc.set.stats.env.noise_sigR0 <- stats.stoc_fast(parms.grid, y0, tMax, nsim) %>%
  # Append parameter values to data frame
  right_join(., select(parms.grid, parms.key, c(b, sigma)), by = "parms.key")
stoc.set.stats.env.noise_sigR0$R0 <- stoc.set.stats.env.noise_sigR0$b
for (par in 1:length(unique(stoc.set.stats.env.noise_sigR0$b))){
  stoc.set.stats.env.noise_sigR0$R0[stoc.set.stats.env.noise_sigR0$b==unique(stoc.set.stats.env.noise_sigR0$sigma)[par]]  <- R0[par]
}


ext_prob_sr= matrix(c(1:(length(unique(stoc.set.stats.env.noise_sigR0$b))*length(unique(stoc.set.stats.env.noise_sigR0$sigma)))), ncol=length(unique(stoc.set.stats.env.noise_sigR0$b)), byrow=TRUE)
colnames(ext_prob_sr) = paste('R0=', round(R0, 3), sep="")
rownames(ext_prob_sr) <- paste('sigma=', sigma, sep="")

for (sig in 1:length(unique(stoc.set.stats.env.noise_sigR0$sigma))) {
  for (r in 1:length(unique(stoc.set.stats.env.noise_sigR0$R0))) {
    ext_prob_sr[sig,r] <- sum(stoc.set.stats.env.noise_sigR0[stoc.set.stats.env.noise_sigR0$sigma==unique(stoc.set.stats.env.noise_sigR0$sigma)[sig] & stoc.set.stats.env.noise_sigR0$R0==unique(stoc.set.stats.env.noise_sigR0$R0)[r], 'ext'])/nsim
  }
}

```
```{r Table: Probability of outbreak dying out, out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:ODEnuminfected} The probability of the outbreak dying out with various levels of environmental noise and various levels of R0.'}
ext_prob_sr_table <- as.table(ext_prob_sr)
ext_prob_sr_table
```
```{r Fig: Relationship between magnitude of environmental noise, R0, and probability of outbreak dying out, out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:SDEnuminfected} The probability of the outbreak dying out versus levels of environmental noise in the SDE model with demographic and environmental stochasticity at various R0s. Both populations are initialized with 10 infected vectors.'}
ext_prob_sr <- as.data.frame(ext_prob_sr)
ext_prob_sr$sigma <- sigma
ext_prob_sr$sigma <- as.factor(ext_prob_sr$sigma)
ext_prob_sr_gr <- gather(ext_prob_sr, key = "state", value = "Probability", paste('R0=', round(R0[1], 3), sep=""):paste('R0=', tail(round(R0, 3), n=1), sep=""))
ext_prob_sr_gr$R0 <- sapply(strsplit(ext_prob_sr_gr$state, split='=', fixed=TRUE), function(x) (x[2]))
ext_prob_sr_gr$R0 <- as.numeric(ext_prob_sr_gr$R0)
ext_prob_sr_gr$R0 <- round(ext_prob_sr_gr$R0, 3)
ggplot(ext_prob_sr_gr, aes(x = sigma, y = Probability, group = R0)) +
  geom_line(aes(color=as.factor(R0))) +
  theme_cowplot() +
  ggtitle("Probability of outbreak dying out by env. noise strength at various R0")
```
```{r Fig: Relationship between magnitude of env. noise, R0, and time of outbreak dying out, out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:SDEnuminfected} The time that the outbreak dies out versus levels of environmental noise in the SDE model with demographic and environmental stochasticity at various R0s. Both populations are initialized with 10 infected vectors.'}

ggplot(data = stoc.set.stats.env.noise_sigR0[stoc.set.stats.env.noise_sigR0$first.ext.time!=Inf,], mapping = aes(x = sigma, y = first.ext.time)) +
  geom_boxplot(aes(group=sigma)) +
  facet_wrap(~as.factor(R0), ncol = 2, scales='free')
```
```{r zoom in on R0 and Sigma expo, echo = FALSE}
b <- c(0.06008328, 0.06166441, 0.06324555, 0.06482669, 0.06640783) # biting rate # R0=0.95; 0.975; 1; 1.025; 1.05
tHV <- 0.5 # transmission prob. from V to H
tVH <- 0.5 # transmission prob. from H to V
NH <- 1000 # host population size
NV <- 10000 # vector population size
gH <- 0.1 # recovery rate of hosts
mV <- 0.1 # mortality of vectors
#** Environmental noise ----
sigma <- seq(0, 0.1, length.out = 11) # strength of env. noise
alphab <- 1 # biting env. noise off
alphat <- 1 # trans. prob. env. noise off
alpham <- 1 # mort. env. noise off

R0 <- sqrt((b^2 * tHV * tVH * NV) / (NH * gH * mV))

Hstar <- max((NH * (b^2 * NV * tHV * tVH - NH * mV * gH)) / (b * tVH * (b * NV * tHV + NH * gH)), 100)
Vstar <- max((b^2 * NV * tVH * tHV - NH * mV * gH) / (b * tHV * (b * tVH + mV)), 1000)
y0 <- c(H = 0, V = 10) # These are numbers of infected, so better to initialize at smaller values
tMax <- 3 * 365 # 500
dt <- 0.01
tspan <- seq(0.0, tMax, dt)
parms.vec <- c(b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV, gH = gH, mV = mV)


# Calculate statistics of SDE trajectories ----
# Number of simulations to run
nsim <- 50
tMax <- 3 * 365
parms.grid <- expand.grid(
  b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV,
  gH = gH, mV = mV, sigma = sigma,
  alphab = alphab,
  alphat = alphat, alpham = alpham
) %>%
  mutate(parms.key = row_number())

stoc.set.stats.env.noise_sigR0 <- stats.stoc_fast(parms.grid, y0, tMax, nsim) %>%
  # Append parameter values to data frame
  right_join(., select(parms.grid, parms.key, c(b, sigma)), by = "parms.key")
stoc.set.stats.env.noise_sigR0$R0 <- stoc.set.stats.env.noise_sigR0$b
for (par in 1:length(unique(stoc.set.stats.env.noise_sigR0$b))){
  stoc.set.stats.env.noise_sigR0$R0[stoc.set.stats.env.noise_sigR0$b==unique(stoc.set.stats.env.noise_sigR0$sigma)[par]]  <- R0[par]
}


ext_prob_sr= matrix(c(1:(length(unique(stoc.set.stats.env.noise_sigR0$b))*length(unique(stoc.set.stats.env.noise_sigR0$sigma)))), ncol=length(unique(stoc.set.stats.env.noise_sigR0$b)), byrow=TRUE)
colnames(ext_prob_sr) = paste('R0=', round(R0, 3), sep="")
rownames(ext_prob_sr) <- paste('sigma=', sigma, sep="")

for (sig in 1:length(unique(stoc.set.stats.env.noise_sigR0$sigma))) {
  for (r in 1:length(unique(stoc.set.stats.env.noise_sigR0$R0))) {
    ext_prob_sr[sig,r] <- sum(stoc.set.stats.env.noise_sigR0[stoc.set.stats.env.noise_sigR0$sigma==unique(stoc.set.stats.env.noise_sigR0$sigma)[sig] & stoc.set.stats.env.noise_sigR0$R0==unique(stoc.set.stats.env.noise_sigR0$R0)[r], 'ext'])/nsim
  }
}

```
```{r Table: Probability of outbreak dying out, out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:ODEnuminfected} The probability of the outbreak dying out with various levels of environmental noise and various levels of R0.'}
ext_prob_sr_table <- as.table(ext_prob_sr)
ext_prob_sr_table
```
```{r Fig: Relationship between magnitude of environmental noise, R0, and probability of outbreak dying out, out.width='100%', fig.height=4, fig.width=6, fig.align='center', fig.cap='\\label{fig:SDEnuminfected} The probability of the outbreak dying out versus levels of environmental noise in the SDE model with demographic and environmental stochasticity at various R0s. Both populations are initialized with 10 infected vectors.'}
ext_prob_sr <- as.data.frame(ext_prob_sr)
ext_prob_sr$sigma <- sigma
ext_prob_sr$sigma <- as.factor(ext_prob_sr$sigma)
ext_prob_sr_gr <- gather(ext_prob_sr, key = "state", value = "Probability", paste('R0=', round(R0[1], 3), sep=""):paste('R0=', tail(round(R0, 3), n=1), sep=""))
ext_prob_sr_gr$R0 <- sapply(strsplit(ext_prob_sr_gr$state, split='=', fixed=TRUE), function(x) (x[2]))
ext_prob_sr_gr$R0 <- as.numeric(ext_prob_sr_gr$R0)
ext_prob_sr_gr$R0 <- round(ext_prob_sr_gr$R0, 3)
ggplot(ext_prob_sr_gr, aes(x = sigma, y = Probability, group = R0)) +
  geom_line(aes(color=as.factor(R0))) +
  theme_cowplot() +
  ggtitle("Probability of outbreak dying out by env. noise strength at various R0")
```




```{r final time exploration-Demographic Stochasticity}
# Make a dataframe with columns: time, state variables (H, V), iteration number, and R0 value
# for R0 < 1, R0 ~= 1, and R0 > 1
# make tMax "large" so we can guess when convergence happens
b_values <- c(0.04743416, 0.06640783, 0.25298221) # biting rate # KD: either 1.05 or 4.74
tHV <- 0.5 # transmission prob. from V to H
tVH <- 0.5 # transmission prob. from H to V
NH <- 1000 # host population size
NV <- 10000 # vector population size
gH <- 0.1 # recovery rate of hosts
mV <- 0.1 # mortality of vectors
#** Environmental noise ----
sigma <- 0.1 # strength of env. noise
alphab <- 1 # biting env. noise off
alphat <- 1 # trans. prob. env. noise off
alpham <- 1 # mort. env. noise off

R0 <- sqrt((b_values^2 * tHV * tVH * NV) / (NH * gH * mV))

Hstar <- max((NH * (b_values^2 * NV * tHV * tVH - NH * mV * gH)) / (b_values * tVH * (b_values * NV * tHV + NH * gH)), 100)
Vstar <- max((b_values^2 * NV * tVH * tHV - NH * mV * gH) / (b_values * tHV * (b_values * tVH + mV)), 1000)

# Initial conditions------------------------------------------------------------
y0 <- c(H = 0, V = 10) # These are numbers of infected, so better to initialize at smaller values
tMax <- 5 * 365 # 500
dt <- 0.01
tspan <- seq(0.0, tMax, dt)

trajectory_convergence_df <- data.frame(matrix(ncol = 5, nrow = 0))
colnames(trajectory_convergence_df) <- c("time", "V", "H", "R0_val", "iteration")

for (b_vals in 1:3) {
  b <- b_values[b_vals]
  parms.vec <- c(b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV, gH = gH, mV = mV)
  

for (iter in 1:5) {
parms.vec_use <- as.list(parms.vec)
parms.vec_use$sigma <- 0 # turn off environmental noise
stoc_result <- f.stoc(tMax, y0, parms.vec_use)
stoc_result$iteration <- as.character(iter)
stoc_result$R0_val <- R0[b_vals]
trajectory_convergence_df <-rbind(trajectory_convergence_df, stoc_result)
}
ode.out <- data.frame(ode(y0, tspan, f, parms.vec))
ode.out$R0_val <-R0[b_vals]
ode.out$iteration <- 'Deterministic model'
trajectory_convergence_df <-rbind(trajectory_convergence_df, ode.out)

}

```
```{r Fig: Trajectories of hosts with demographic noise only, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} Trajectories of infected host population over time in the SDE model with demographic stochasticity at various R0s. Both populations are initialized with 10 infected vectors.'}

ggplot(data = trajectory_convergence_df , mapping = aes(x = time, y = H, color=as.factor(iteration))) +
  geom_line() +facet_wrap(~as.factor(R0_val), ncol = 1, scales='free')
```





```{r Fig: Trajectories of vectors with demographic noise only, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} Trajectories of infected host population over time in the SDE model with demographic stochasticity at various R0s. Both populations are initialized with 10 infected vectors.'}

ggplot(data = trajectory_convergence_df, mapping = aes(x = time, y = V, color=as.factor(iteration))) +
  geom_line() +
  facet_wrap(~as.factor(R0_val), ncol = 1, scales='free')
```


```{r final time exploration-Dem. and Env. Noise Sigma=0.05}
# Make a dataframe with columns: time, state variables (H, V), iteration number, and R0 value
# for R0 < 1, R0 ~= 1, and R0 > 1
# make tMax "large" so we can guess when convergence happens
b_values <- c(0.04743416, 0.06640783, 0.25298221) # biting rate # KD: either 1.05 or 4.74
tHV <- 0.5 # transmission prob. from V to H
tVH <- 0.5 # transmission prob. from H to V
NH <- 1000 # host population size
NV <- 10000 # vector population size
gH <- 0.1 # recovery rate of hosts
mV <- 0.1 # mortality of vectors
#** Environmental noise ----
sigma <-0.05 # strength of env. noise
alphab <- 1 # biting env. noise off
alphat <- 1 # trans. prob. env. noise off
alpham <- 1 # mort. env. noise off

R0 <- sqrt((b_values^2 * tHV * tVH * NV) / (NH * gH * mV))

Hstar <- max((NH * (b_values^2 * NV * tHV * tVH - NH * mV * gH)) / (b_values * tVH * (b_values * NV * tHV + NH * gH)), 100)
Vstar <- max((b_values^2 * NV * tVH * tHV - NH * mV * gH) / (b_values * tHV * (b_values * tVH + mV)), 1000)

# Initial conditions------------------------------------------------------------
y0 <- c(H = 0, V = 10) # These are numbers of infected, so better to initialize at smaller values
tMax <- 5 * 365 # 500
dt <- 0.01
tspan <- seq(0.0, tMax, dt)

trajectory_convergence_df <- data.frame(matrix(ncol = 5, nrow = 0))
colnames(trajectory_convergence_df) <- c("time", "V", "H", "R0_val", "iteration")

for (b_vals in 1:3) {
  b <- b_values[b_vals]
  parms.vec <- c(b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV, gH = gH, mV = mV)
  

for (iter in 1:5) {
parms.vec_use <- as.list(parms.vec)
parms.vec_use$sigma <- sigma
stoc_result <- f.stoc(tMax, y0, parms.vec_use)
stoc_result$iteration <- as.character(iter)
stoc_result$R0_val <- R0[b_vals]
trajectory_convergence_df <-rbind(trajectory_convergence_df, stoc_result)
}
ode.out <- data.frame(ode(y0, tspan, f, parms.vec))
ode.out$R0_val <-R0[b_vals]
ode.out$iteration <- 'Deterministic model'
trajectory_convergence_df <-rbind(trajectory_convergence_df, ode.out)

}

```
```{r Fig: Trajectories of hosts with dem. and env. noise, sigma=0.05, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} Trajectories of infected host population over time in the SDE model with dem. and env. stochasticity with sigma=0.05 at various R0s. Both populations are initialized with 10 infected vectors.'}

ggplot(data = trajectory_convergence_df , mapping = aes(x = time, y = H, color=as.factor(iteration))) +
  geom_line() +facet_wrap(~as.factor(R0_val), ncol = 1, scales='free')+ggtitle('sigma=0.05')
```





```{r Fig: Trajectories of vectors with dem. and env. noise, sigma=0.05, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} Trajectories of infected host population over time in the SDE model with dem. and env. noise, sigma=0.05 at various R0s. Both populations are initialized with 10 infected vectors.'}

ggplot(data = trajectory_convergence_df, mapping = aes(x = time, y = V, color=as.factor(iteration))) +
  geom_line() +
  facet_wrap(~as.factor(R0_val), ncol = 1, scales='free')+ggtitle('sigma=0.05')
```
```{r final time exploration-Dem. and Env. Noise Sigma=0.1}
# Make a dataframe with columns: time, state variables (H, V), iteration number, and R0 value
# for R0 < 1, R0 ~= 1, and R0 > 1
# make tMax "large" so we can guess when convergence happens
b_values <- c(0.04745334, 0.06, 0.06666667, 0.2553191) # biting rate # KD: either 1.05 or 4.74
tHV <- 0.5 # transmission prob. from V to H
tVH <- 0.5 # transmission prob. from H to V
NH <- 1000 # host population size
NV <- 10000 # vector population size
gH <- 0.1 # recovery rate of hosts
mV <- 0.1 # mortality of vectors
#** Environmental noise ----
sigma <-0.1 # strength of env. noise
alphab <- 1 # biting env. noise off
alphat <- 1 # trans. prob. env. noise off
alpham <- 1 # mort. env. noise off

R0 <- sqrt((b_values^2 * tHV * tVH * NV) / (NH * gH * mV))

Hstar <- max((NH * (b_values^2 * NV * tHV * tVH - NH * mV * gH)) / (b_values * tVH * (b_values * NV * tHV + NH * gH)), 100)
Vstar <- max((b_values^2 * NV * tVH * tHV - NH * mV * gH) / (b_values * tHV * (b_values * tVH + mV)), 1000)

# Initial conditions------------------------------------------------------------
y0 <- c(H = 0, V = 10) # These are numbers of infected, so better to initialize at smaller values
tMax <- 10 * 365 # 500
dt <- 0.01
tspan <- seq(0.0, tMax, dt)

trajectory_convergence_df <- data.frame(matrix(ncol = 5, nrow = 0))
colnames(trajectory_convergence_df) <- c("time", "V", "H", "R0_val", "iteration")

for (b_vals in 1:4) {
  b <- b_values[b_vals]
  parms.vec <- c(b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV, gH = gH, mV = mV)
  

for (iter in 1:5) {
parms.vec_use <- as.list(parms.vec)
parms.vec_use$sigma <- sigma
stoc_result <- f.stoc(tMax, y0, parms.vec_use)
stoc_result$iteration <- as.character(iter)
stoc_result$R0_val <- R0[b_vals]
trajectory_convergence_df <-rbind(trajectory_convergence_df, stoc_result)
}
ode.out <- data.frame(ode(y0, tspan, f, parms.vec))
ode.out$R0_val <-R0[b_vals]
ode.out$iteration <- 'Deterministic model'
trajectory_convergence_df <-rbind(trajectory_convergence_df, ode.out)

}

```
```{r Fig: Trajectories of hosts with dem. and env. noise, sigma=0.1, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} Trajectories of infected host population over time in the SDE model with dem. and env. stochasticity with sigma=0.1 at various R0s. Both populations are initialized with 10 infected vectors.'}

ggplot(data = trajectory_convergence_df , mapping = aes(x = time, y = H, color=as.factor(iteration))) +
  geom_line() +facet_wrap(~as.factor(R0_val), ncol = 1, scales='free')+ggtitle('sigma=0.1')
```
```{r Fig: Trajectories of vectors with dem. and env. noise, sigma=0.1, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} Trajectories of infected host population over time in the SDE model with dem. and env. noise, sigma=0.1 at various R0s. Both populations are initialized with 10 infected vectors.'}

ggplot(data = trajectory_convergence_df, mapping = aes(x = time, y = V, color=as.factor(iteration))) +
  geom_line() +
  facet_wrap(~as.factor(R0_val), ncol = 1, scales='free')+ggtitle('sigma=0.1')
```

```{r final time exploration-Dem. and Env. Noise Sigma=0.025}
# Make a dataframe with columns: time, state variables (H, V), iteration number, and R0 value
# for R0 < 1, R0 ~= 1, and R0 > 1
# make tMax "large" so we can guess when convergence happens
b_values <- c(0.04745334, 0.06, 0.06666667, 0.2553191) # biting rate # KD: either 1.05 or 4.74
tHV <- 0.5 # transmission prob. from V to H
tVH <- 0.5 # transmission prob. from H to V
NH <- 1000 # host population size
NV <- 10000 # vector population size
gH <- 0.1 # recovery rate of hosts
mV <- 0.1 # mortality of vectors
#Environmental noise ----
sigma <-0.025 # strength of env. noise
alphab <- 1 # biting env. noise off
alphat <- 1 # trans. prob. env. noise off
alpham <- 1 # mort. env. noise off

R0 <- sqrt((b_values^2 * tHV * tVH * NV) / (NH * gH * mV))

Hstar <- max((NH * (b_values^2 * NV * tHV * tVH - NH * mV * gH)) / (b_values * tVH * (b_values * NV * tHV + NH * gH)), 100)
Vstar <- max((b_values^2 * NV * tVH * tHV - NH * mV * gH) / (b_values * tHV * (b_values * tVH + mV)), 1000)

# Initial conditions------------------------------------------------------------
y0 <- c(H = 0, V = 10) # These are numbers of infected, so better to initialize at smaller values
tMax <- 10 * 365 # 500
dt <- 0.01
tspan <- seq(0.0, tMax, dt)

trajectory_convergence_df <- data.frame(matrix(ncol = 5, nrow = 0))
colnames(trajectory_convergence_df) <- c("time", "V", "H", "R0_val", "iteration")

for (b_vals in 1:4) {
  b <- b_values[b_vals]
  parms.vec <- c(b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV, gH = gH, mV = mV)
  

for (iter in 1:5) {
parms.vec_use <- as.list(parms.vec)
parms.vec_use$sigma <- sigma
stoc_result <- f.stoc(tMax, y0, parms.vec_use)
stoc_result$iteration <- as.character(iter)
stoc_result$R0_val <- R0[b_vals]
trajectory_convergence_df <-rbind(trajectory_convergence_df, stoc_result)
}
ode.out <- data.frame(ode(y0, tspan, f, parms.vec))
ode.out$R0_val <-R0[b_vals]
ode.out$iteration <- 'Deterministic model'
trajectory_convergence_df <-rbind(trajectory_convergence_df, ode.out)

}

```
```{r Fig: Trajectories of hosts with dem. and env. noise, sigma=0.025, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} Trajectories of infected host population over time in the SDE model with dem. and env. stochasticity with sigma=0.025 at various R0s. Both populations are initialized with 10 infected vectors.'}

ggplot(data = trajectory_convergence_df , mapping = aes(x = time, y = H, color=as.factor(iteration))) +
  geom_line() +facet_wrap(~as.factor(R0_val), ncol = 1, scales='free')+ggtitle('sigma=0.025')
```
```{r Fig: Trajectories of vectors with dem. and env. noise, sigma=0.025, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} Trajectories of infected host population over time in the SDE model with dem. and env. noise, sigma=0.025 at various R0s. Both populations are initialized with 10 infected vectors.'}

ggplot(data = trajectory_convergence_df, mapping = aes(x = time, y = V, color=as.factor(iteration))) +
  geom_line() +
  facet_wrap(~as.factor(R0_val), ncol = 1, scales='free')+ggtitle('sigma=0.025')
```

```{r final time exploration-Dem. and Env. Noise, Sigma=0.075}
# Make a dataframe with columns: time, state variables (H, V), iteration number, and R0 value
# for R0 < 1, R0 ~= 1, and R0 > 1
# make tMax "large" so we can guess when convergence happens
b_values <- c(0.04745334, 0.06, 0.06666667, 0.2553191) # biting rate # KD: either 1.05 or 4.74
tHV <- 0.5 # transmission prob. from V to H
tVH <- 0.5 # transmission prob. from H to V
NH <- 1000 # host population size
NV <- 10000 # vector population size
gH <- 0.1 # recovery rate of hosts
mV <- 0.1 # mortality of vectors
#** Environmental noise ----
sigma <-0.075 # strength of env. noise
alphab <- 1 # biting env. noise off
alphat <- 1 # trans. prob. env. noise off
alpham <- 1 # mort. env. noise off

R0 <- sqrt((b_values^2 * tHV * tVH * NV) / (NH * gH * mV))

Hstar <- max((NH * (b_values^2 * NV * tHV * tVH - NH * mV * gH)) / (b_values * tVH * (b_values * NV * tHV + NH * gH)), 100)
Vstar <- max((b_values^2 * NV * tVH * tHV - NH * mV * gH) / (b_values * tHV * (b_values * tVH + mV)), 1000)

# Initial conditions------------------------------------------------------------
y0 <- c(H = 0, V = 10) # These are numbers of infected, so better to initialize at smaller values
tMax <- 10 * 365 # 500
dt <- 0.01
tspan <- seq(0.0, tMax, dt)

trajectory_convergence_df <- data.frame(matrix(ncol = 5, nrow = 0))
colnames(trajectory_convergence_df) <- c("time", "V", "H", "R0_val", "iteration")

for (b_vals in 1:4) {
  b <- b_values[b_vals]
  parms.vec <- c(b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV, gH = gH, mV = mV)
  

for (iter in 1:5) {
parms.vec_use <- as.list(parms.vec)
parms.vec_use$sigma <- sigma
stoc_result <- f.stoc(tMax, y0, parms.vec_use)
stoc_result$iteration <- as.character(iter)
stoc_result$R0_val <- R0[b_vals]
trajectory_convergence_df <-rbind(trajectory_convergence_df, stoc_result)
}
ode.out <- data.frame(ode(y0, tspan, f, parms.vec))
ode.out$R0_val <-R0[b_vals]
ode.out$iteration <- 'Deterministic model'
trajectory_convergence_df <-rbind(trajectory_convergence_df, ode.out)

}

```
```{r Fig: Trajectories of hosts with dem. and env. noise, sigma=0.075, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} Trajectories of infected host population over time in the SDE model with dem. and env. stochasticity with sigma=0.075 at various R0s. Both populations are initialized with 10 infected vectors.'}

ggplot(data = trajectory_convergence_df , mapping = aes(x = time, y = H, color=as.factor(iteration))) +
  geom_line() +facet_wrap(~as.factor(R0_val), ncol = 1, scales='free')+ggtitle('sigma=0.075')
```
```{r Fig: Trajectories of vectors with dem. and env. noise, sigma=0.075, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} Trajectories of infected host population over time in the SDE model with dem. and env. noise, sigma=0.075 at various R0s. Both populations are initialized with 10 infected vectors.'}

ggplot(data = trajectory_convergence_df, mapping = aes(x = time, y = V, color=as.factor(iteration))) +
  geom_line() +
  facet_wrap(~as.factor(R0_val), ncol = 1, scales='free')+ggtitle('sigma=0.075')
```

```{r final time exploration-Dem. and Env. Noise, Sigma=0.001}
# Make a dataframe with columns: time, state variables (H, V), iteration number, and R0 value
# for R0 < 1, R0 ~= 1, and R0 > 1
# make tMax "large" so we can guess when convergence happens
b_values <- c(0.04745334, 0.06, 0.06666667, 0.2553191) # biting rate # KD: either 1.05 or 4.74
tHV <- 0.5 # transmission prob. from V to H
tVH <- 0.5 # transmission prob. from H to V
NH <- 1000 # host population size
NV <- 10000 # vector population size
gH <- 0.1 # recovery rate of hosts
mV <- 0.1 # mortality of vectors
#** Environmental noise ----
sigma <-0.001 # strength of env. noise
alphab <- 1 # biting env. noise off
alphat <- 1 # trans. prob. env. noise off
alpham <- 1 # mort. env. noise off

R0 <- sqrt((b_values^2 * tHV * tVH * NV) / (NH * gH * mV))

Hstar <- max((NH * (b_values^2 * NV * tHV * tVH - NH * mV * gH)) / (b_values * tVH * (b_values * NV * tHV + NH * gH)), 100)
Vstar <- max((b_values^2 * NV * tVH * tHV - NH * mV * gH) / (b_values * tHV * (b_values * tVH + mV)), 1000)

# Initial conditions------------------------------------------------------------
y0 <- c(H = 0, V = 10) # These are numbers of infected, so better to initialize at smaller values
tMax <- 10 * 365 # 500
dt <- 0.01
tspan <- seq(0.0, tMax, dt)

trajectory_convergence_df <- data.frame(matrix(ncol = 5, nrow = 0))
colnames(trajectory_convergence_df) <- c("time", "V", "H", "R0_val", "iteration")

for (b_vals in 1:4) {
  b <- b_values[b_vals]
  parms.vec <- c(b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV, gH = gH, mV = mV)
  

for (iter in 1:5) {
parms.vec_use <- as.list(parms.vec)
parms.vec_use$sigma <- sigma
stoc_result <- f.stoc(tMax, y0, parms.vec_use)
stoc_result$iteration <- as.character(iter)
stoc_result$R0_val <- R0[b_vals]
trajectory_convergence_df <-rbind(trajectory_convergence_df, stoc_result)
}
ode.out <- data.frame(ode(y0, tspan, f, parms.vec))
ode.out$R0_val <-R0[b_vals]
ode.out$iteration <- 'Deterministic model'
trajectory_convergence_df <-rbind(trajectory_convergence_df, ode.out)

}

```
```{r Fig: Trajectories of hosts with dem. and env. noise, sigma=0.001, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} Trajectories of infected host population over time in the SDE model with dem. and env. stochasticity with sigma=0.001 at various R0s. Both populations are initialized with 10 infected vectors.'}

ggplot(data = trajectory_convergence_df , mapping = aes(x = time, y = H, color=as.factor(iteration))) +
  geom_line() +facet_wrap(~as.factor(R0_val), ncol = 1, scales='free')+ggtitle('sigma=0.001')
```
```{r Fig: Trajectories of vectors with dem. and env. noise, sigma=0.001, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} Trajectories of infected host population over time in the SDE model with dem. and env. noise, sigma=0.001 at various R0s. Both populations are initialized with 10 infected vectors.'}

ggplot(data = trajectory_convergence_df, mapping = aes(x = time, y = V, color=as.factor(iteration))) +
  geom_line() +
  facet_wrap(~as.factor(R0_val), ncol = 1, scales='free')+ggtitle('sigma=0.001')
```


```{r Population Size Exploration, echo = FALSE}
#Does the population size (Mosquito:Human ratio constant) impact the probability of outbreak dying out?
#R0=0.75
ext_prob= matrix(c(1:9), ncol=3, byrow=TRUE)
colnames(ext_prob) = c('100H; 1,000M','1,000H; 10,000M', '10,000H; 100,000M')
rownames(ext_prob) <- c('Det.','Dem. Noise','Dem. & Env. Noise')
ext_prob[1,1] <- 1
ext_prob[1,2] <- 1
ext_prob[1,3] <- 1

#Setting tMax=3 years based on preliminaries
#Selecting sigma=0.05 as baseline based on preliminaries
#R0=0.75
# Parameters 
b <- 0.04743416 # biting rate # KD: either 1.05 or 4.74
tHV <- 0.5 # transmission prob. from V to H
tVH <- 0.5 # transmission prob. from H to V
NH_vals <- c(100, 1000, 10000) # host population size
NV_vals <- c(1000, 10000, 100000) # vector population size
gH <- 0.1 # recovery rate of hosts
mV <- 0.1 # mortality of vectors
# Environmental noise 
sigma <- 0.05 # strength of env. noise
alphab <- 1 # biting env. noise off
alphat <- 1 # trans. prob. env. noise off
alpham <- 1 # mort. env. noise off

R0 <- sqrt((b^2 * tHV * tVH * NV) / (NH * gH * mV))

Hstar <- max((NH * (b^2 * NV * tHV * tVH - NH * mV * gH)) / (b * tVH * (b * NV * tHV + NH * gH)), 100)
Vstar <- max((b^2 * NV * tVH * tHV - NH * mV * gH) / (b * tHV * (b * tVH + mV)), 1000)

# Initial conditions
y0 <- c(H = 0, V = 10) # These are numbers of infected, so better to initialize at smaller values
tMax <- 3 * 365 # 500
dt <- 0.01
tspan <- seq(0.0, tMax, dt)

for (index in 1:3) {
  NH <- NH_vals[index]
  NV <- NV_vals[index]
parms.vec <- c(b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV, gH = gH, mV = mV)

# Calculate statistics of SDE trajectories 
# Number of simulations to run
nsim <- 100
tMax <- 3 * 365
parms.grid <- expand.grid(
  b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV,
  gH = gH, mV = mV, sigma = sigma,
  alphab = alphab,
  alphat = alphat, alpham = alpham
) %>%
  mutate(parms.key = row_number())

# parameters with demographic noise ONLY
parms.grid.dem.noise <- parms.grid %>% 
  mutate(alphab = 0) %>% 
  mutate(alphat = 0) %>% 
  mutate(alpham = 0) %>%
  mutate(sigma = 0)

stoc.set.stats.dem.noise <- stats.stoc_fast(parms.grid.dem.noise, y0, tMax, nsim) %>%
  # Append parameter values to data frame
  right_join(., select(parms.grid.dem.noise, parms.key, sigma), by = "parms.key")
#calculate the probability of disease dying out out of 100 simulations
ext_prob[2,index] <- sum(stoc.set.stats.dem.noise$ext)/nsim

stoc.set.stats.demenv.noise <- stats.stoc_fast(parms.grid, y0, tMax, nsim) %>%
  # Append parameter values to data frame
  right_join(., select(parms.grid, parms.key, sigma), by = "parms.key")
#calculate the probability of disease dying out out of 100 simulations 
ext_prob[3,index] <- sum(stoc.set.stats.demenv.noise$ext)/nsim
}
ext_prob <- as.table(ext_prob)
ext_prob
```
```{r Population Size Exploration, echo = FALSE}
#Does the population size (Mosquito:Human ratio constant) impact the probability of outbreak dying out?
#R0=0.95
ext_prob= matrix(c(1:9), ncol=3, byrow=TRUE)
colnames(ext_prob) = c('100H; 1,000M','1,000H; 10,000M', '10,000H; 100,000M')
rownames(ext_prob) <- c('Det.','Dem. Noise','Dem. & Env. Noise')
ext_prob[1,1] <- 1
ext_prob[1,2] <- 1
ext_prob[1,3] <- 1

#Setting tMax=3 years based on preliminaries
#Selecting sigma=0.05 as baseline based on preliminaries
#R0=0.95
# Parameters 
b <- 0.06008328 # biting rate # KD: either 1.05 or 4.74
tHV <- 0.5 # transmission prob. from V to H
tVH <- 0.5 # transmission prob. from H to V
NH_vals <- c(100, 1000, 10000) # host population size
NV_vals <- c(1000, 10000, 100000) # vector population size
gH <- 0.1 # recovery rate of hosts
mV <- 0.1 # mortality of vectors
# Environmental noise 
sigma <- 0.05 # strength of env. noise
alphab <- 1 # biting env. noise off
alphat <- 1 # trans. prob. env. noise off
alpham <- 1 # mort. env. noise off

R0 <- sqrt((b^2 * tHV * tVH * NV) / (NH * gH * mV))

Hstar <- max((NH * (b^2 * NV * tHV * tVH - NH * mV * gH)) / (b * tVH * (b * NV * tHV + NH * gH)), 100)
Vstar <- max((b^2 * NV * tVH * tHV - NH * mV * gH) / (b * tHV * (b * tVH + mV)), 1000)

# Initial conditions
y0 <- c(H = 0, V = 10) # These are numbers of infected, so better to initialize at smaller values
tMax <- 3 * 365 # 500
dt <- 0.01
tspan <- seq(0.0, tMax, dt)

for (index in 1:3) {
  NH <- NH_vals[index]
  NV <- NV_vals[index]
parms.vec <- c(b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV, gH = gH, mV = mV)

# Calculate statistics of SDE trajectories 
# Number of simulations to run
nsim <- 100
tMax <- 3 * 365
parms.grid <- expand.grid(
  b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV,
  gH = gH, mV = mV, sigma = sigma,
  alphab = alphab,
  alphat = alphat, alpham = alpham
) %>%
  mutate(parms.key = row_number())

# parameters with demographic noise ONLY
parms.grid.dem.noise <- parms.grid %>% 
  mutate(alphab = 0) %>% 
  mutate(alphat = 0) %>% 
  mutate(alpham = 0) %>%
  mutate(sigma = 0)

stoc.set.stats.dem.noise <- stats.stoc_fast(parms.grid.dem.noise, y0, tMax, nsim) %>%
  # Append parameter values to data frame
  right_join(., select(parms.grid.dem.noise, parms.key, sigma), by = "parms.key")
#calculate the probability of disease dying out out of 100 simulations
ext_prob[2,index] <- sum(stoc.set.stats.dem.noise$ext)/nsim

stoc.set.stats.demenv.noise <- stats.stoc_fast(parms.grid, y0, tMax, nsim) %>%
  # Append parameter values to data frame
  right_join(., select(parms.grid, parms.key, sigma), by = "parms.key")
#calculate the probability of disease dying out out of 100 simulations 
ext_prob[3,index] <- sum(stoc.set.stats.demenv.noise$ext)/nsim
}
ext_prob <- as.table(ext_prob)
ext_prob
```
```{r Population Size Exploration, echo = FALSE}
#Does the population size (Mosquito:Human ratio constant) impact the probability of outbreak dying out?
#R0=1.05
ext_prob= matrix(c(1:9), ncol=3, byrow=TRUE)
colnames(ext_prob) = c('100H; 1,000M','1,000H; 10,000M', '10,000H; 100,000M')
rownames(ext_prob) <- c('Det.','Dem. Noise','Dem. & Env. Noise')
ext_prob[1,1] <- 0
ext_prob[1,2] <- 0
ext_prob[1,3] <- 0

#Setting tMax=3 years based on preliminaries
#Selecting sigma=0.05 as baseline based on preliminaries
#R0=1.05
# Parameters 
b <- 0.06640783 # biting rate # KD: either 1.05 or 4.74
tHV <- 0.5 # transmission prob. from V to H
tVH <- 0.5 # transmission prob. from H to V
NH_vals <- c(100, 1000, 10000) # host population size
NV_vals <- c(1000, 10000, 100000) # vector population size
gH <- 0.1 # recovery rate of hosts
mV <- 0.1 # mortality of vectors
# Environmental noise 
sigma <- 0.05 # strength of env. noise
alphab <- 1 # biting env. noise off
alphat <- 1 # trans. prob. env. noise off
alpham <- 1 # mort. env. noise off

R0 <- sqrt((b^2 * tHV * tVH * NV) / (NH * gH * mV))

Hstar <- max((NH * (b^2 * NV * tHV * tVH - NH * mV * gH)) / (b * tVH * (b * NV * tHV + NH * gH)), 100)
Vstar <- max((b^2 * NV * tVH * tHV - NH * mV * gH) / (b * tHV * (b * tVH + mV)), 1000)

# Initial conditions
y0 <- c(H = 0, V = 10) # These are numbers of infected, so better to initialize at smaller values
tMax <- 3 * 365 # 500
dt <- 0.01
tspan <- seq(0.0, tMax, dt)

for (index in 1:3) {
  NH <- NH_vals[index]
  NV <- NV_vals[index]
parms.vec <- c(b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV, gH = gH, mV = mV)

# Calculate statistics of SDE trajectories 
# Number of simulations to run
nsim <- 100
tMax <- 3 * 365
parms.grid <- expand.grid(
  b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV,
  gH = gH, mV = mV, sigma = sigma,
  alphab = alphab,
  alphat = alphat, alpham = alpham
) %>%
  mutate(parms.key = row_number())

# parameters with demographic noise ONLY
parms.grid.dem.noise <- parms.grid %>% 
  mutate(alphab = 0) %>% 
  mutate(alphat = 0) %>% 
  mutate(alpham = 0) %>%
  mutate(sigma = 0)

stoc.set.stats.dem.noise <- stats.stoc_fast(parms.grid.dem.noise, y0, tMax, nsim) %>%
  # Append parameter values to data frame
  right_join(., select(parms.grid.dem.noise, parms.key, sigma), by = "parms.key")
#calculate the probability of disease dying out out of 100 simulations
ext_prob[2,index] <- sum(stoc.set.stats.dem.noise$ext)/nsim

stoc.set.stats.demenv.noise <- stats.stoc_fast(parms.grid, y0, tMax, nsim) %>%
  # Append parameter values to data frame
  right_join(., select(parms.grid, parms.key, sigma), by = "parms.key")
#calculate the probability of disease dying out out of 100 simulations 
ext_prob[3,index] <- sum(stoc.set.stats.demenv.noise$ext)/nsim
}
ext_prob <- as.table(ext_prob)
ext_prob
```
```{r Population Size Exploration, echo = FALSE}
#Does the population size (Mosquito:Human ratio constant) impact the probability of outbreak dying out?
#R0=4
ext_prob= matrix(c(1:9), ncol=3, byrow=TRUE)
colnames(ext_prob) = c('100H; 1,000M','1,000H; 10,000M', '10,000H; 100,000M')
rownames(ext_prob) <- c('Det.','Dem. Noise','Dem. & Env. Noise')
ext_prob[1,1] <- 0
ext_prob[1,2] <- 0
ext_prob[1,3] <- 0

#Setting tMax=3 years based on preliminaries
#Selecting sigma=0.05 as baseline based on preliminaries
#R0=4
# Parameters 
b <- 0.25298221 # biting rate # KD: either 1.05 or 4.74
tHV <- 0.5 # transmission prob. from V to H
tVH <- 0.5 # transmission prob. from H to V
NH_vals <- c(100, 1000, 10000) # host population size
NV_vals <- c(1000, 10000, 100000) # vector population size
gH <- 0.1 # recovery rate of hosts
mV <- 0.1 # mortality of vectors
# Environmental noise 
sigma <- 0.05 # strength of env. noise
alphab <- 1 # biting env. noise off
alphat <- 1 # trans. prob. env. noise off
alpham <- 1 # mort. env. noise off

R0 <- sqrt((b^2 * tHV * tVH * NV) / (NH * gH * mV))

Hstar <- max((NH * (b^2 * NV * tHV * tVH - NH * mV * gH)) / (b * tVH * (b * NV * tHV + NH * gH)), 100)
Vstar <- max((b^2 * NV * tVH * tHV - NH * mV * gH) / (b * tHV * (b * tVH + mV)), 1000)

# Initial conditions
y0 <- c(H = 0, V = 10) # These are numbers of infected, so better to initialize at smaller values
tMax <- 3 * 365 # 500
dt <- 0.01
tspan <- seq(0.0, tMax, dt)

for (index in 1:3) {
  NH <- NH_vals[index]
  NV <- NV_vals[index]
parms.vec <- c(b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV, gH = gH, mV = mV)

# Calculate statistics of SDE trajectories 
# Number of simulations to run
nsim <- 100
tMax <- 3 * 365
parms.grid <- expand.grid(
  b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV,
  gH = gH, mV = mV, sigma = sigma,
  alphab = alphab,
  alphat = alphat, alpham = alpham
) %>%
  mutate(parms.key = row_number())

# parameters with demographic noise ONLY
parms.grid.dem.noise <- parms.grid %>% 
  mutate(alphab = 0) %>% 
  mutate(alphat = 0) %>% 
  mutate(alpham = 0) %>%
  mutate(sigma = 0)

stoc.set.stats.dem.noise <- stats.stoc_fast(parms.grid.dem.noise, y0, tMax, nsim) %>%
  # Append parameter values to data frame
  right_join(., select(parms.grid.dem.noise, parms.key, sigma), by = "parms.key")
#calculate the probability of disease dying out out of 100 simulations
ext_prob[2,index] <- sum(stoc.set.stats.dem.noise$ext)/nsim

stoc.set.stats.demenv.noise <- stats.stoc_fast(parms.grid, y0, tMax, nsim) %>%
  # Append parameter values to data frame
  right_join(., select(parms.grid, parms.key, sigma), by = "parms.key")
#calculate the probability of disease dying out out of 100 simulations 
ext_prob[3,index] <- sum(stoc.set.stats.demenv.noise$ext)/nsim
}
ext_prob <- as.table(ext_prob)
ext_prob
```

```{r Mosquito:Human ratio Exploration, echo = FALSE}
#Does the Mosquito:Human ratio impact the probability of outbreak dying out?
#R0=1.05
ext_prob= matrix(c(1:9), ncol=3, byrow=TRUE)
colnames(ext_prob) = c('1000H; 10,000M','1,000H; 100,000M', '1,000H; 1,000,000M')
rownames(ext_prob) <- c('Det.','Dem. Noise','Dem. & Env. Noise')
ext_prob[1,1] <- 0
ext_prob[1,2] <- 0
ext_prob[1,3] <- 0

#Setting tMax=3 years based on preliminaries
#Selecting sigma=0.05 as baseline based on preliminaries
#R0=1.05
# Parameters 
b_vals <- c(0.066407831, 0.021000000, 0.006640783) # different b because R0 varies with M:H ratio
tHV <- 0.5 # transmission prob. from V to H
tVH <- 0.5 # transmission prob. from H to V
NH <- 1000 # host population size
NV_vals <- c(10000, 100000, 1000000) # vector population size
gH <- 0.1 # recovery rate of hosts
mV <- 0.1 # mortality of vectors
# Environmental noise 
sigma <- 0.05 # strength of env. noise
alphab <- 1 # biting env. noise off
alphat <- 1 # trans. prob. env. noise off
alpham <- 1 # mort. env. noise off

R0 <- sqrt((b^2 * tHV * tVH * NV) / (NH * gH * mV))

Hstar <- max((NH * (b^2 * NV * tHV * tVH - NH * mV * gH)) / (b * tVH * (b * NV * tHV + NH * gH)), 100)
Vstar <- max((b^2 * NV * tVH * tHV - NH * mV * gH) / (b * tHV * (b * tVH + mV)), 1000)

# Initial conditions
y0 <- c(H = 0, V = 10) # These are numbers of infected, so better to initialize at smaller values
tMax <- 3 * 365 # 500
dt <- 0.01
tspan <- seq(0.0, tMax, dt)

for (index in 1:3) {
  b <- b_vals[index]
  NV <- NV_vals[index]
parms.vec <- c(b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV, gH = gH, mV = mV)

# Calculate statistics of SDE trajectories 
# Number of simulations to run
nsim <- 100
tMax <- 3 * 365
parms.grid <- expand.grid(
  b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV,
  gH = gH, mV = mV, sigma = sigma,
  alphab = alphab,
  alphat = alphat, alpham = alpham
) %>%
  mutate(parms.key = row_number())

# parameters with demographic noise ONLY
parms.grid.dem.noise <- parms.grid %>% 
  mutate(alphab = 0) %>% 
  mutate(alphat = 0) %>% 
  mutate(alpham = 0) %>%
  mutate(sigma = 0)

stoc.set.stats.dem.noise <- stats.stoc_fast(parms.grid.dem.noise, y0, tMax, nsim) %>%
  # Append parameter values to data frame
  right_join(., select(parms.grid.dem.noise, parms.key, sigma), by = "parms.key")
#calculate the probability of disease dying out out of 100 simulations
ext_prob[2,index] <- sum(stoc.set.stats.dem.noise$ext)/nsim

stoc.set.stats.demenv.noise <- stats.stoc_fast(parms.grid, y0, tMax, nsim) %>%
  # Append parameter values to data frame
  right_join(., select(parms.grid, parms.key, sigma), by = "parms.key")
#calculate the probability of disease dying out out of 100 simulations 
ext_prob[3,index] <- sum(stoc.set.stats.demenv.noise$ext)/nsim
}
ext_prob <- as.table(ext_prob)
ext_prob
```
```{r Mosquito:Human ratio Exploration, echo = FALSE}
#Does the Mosquito:Human ratio impact the probability of outbreak dying out?
#R0=0.75
ext_prob= matrix(c(1:9), ncol=3, byrow=TRUE)
colnames(ext_prob) = c('1000H; 10,000M','1,000H; 100,000M', '1,000H; 1,000,000M')
rownames(ext_prob) <- c('Det.','Dem. Noise','Dem. & Env. Noise')
ext_prob[1,1] <- 1
ext_prob[1,2] <- 1
ext_prob[1,3] <- 1

#Setting tMax=3 years based on preliminaries
#Selecting sigma=0.05 as baseline based on preliminaries
#R0=0.75
# Parameters 
b_vals <- c(0.047434165, 0.015000000, 0.004743416) # different b because R0 varies with M:H ratio
tHV <- 0.5 # transmission prob. from V to H
tVH <- 0.5 # transmission prob. from H to V
NH <- 1000 # host population size
NV_vals <- c(10000, 100000, 1000000) # vector population size
gH <- 0.1 # recovery rate of hosts
mV <- 0.1 # mortality of vectors
# Environmental noise 
sigma <- 0.05 # strength of env. noise
alphab <- 1 # biting env. noise off
alphat <- 1 # trans. prob. env. noise off
alpham <- 1 # mort. env. noise off

R0 <- sqrt((b^2 * tHV * tVH * NV) / (NH * gH * mV))

Hstar <- max((NH * (b^2 * NV * tHV * tVH - NH * mV * gH)) / (b * tVH * (b * NV * tHV + NH * gH)), 100)
Vstar <- max((b^2 * NV * tVH * tHV - NH * mV * gH) / (b * tHV * (b * tVH + mV)), 1000)

# Initial conditions
y0 <- c(H = 0, V = 10) # These are numbers of infected, so better to initialize at smaller values
tMax <- 3 * 365 # 500
dt <- 0.01
tspan <- seq(0.0, tMax, dt)

for (index in 1:3) {
  b <- b_vals[index]
  NV <- NV_vals[index]
parms.vec <- c(b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV, gH = gH, mV = mV)

# Calculate statistics of SDE trajectories 
# Number of simulations to run
nsim <- 100
tMax <- 3 * 365
parms.grid <- expand.grid(
  b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV,
  gH = gH, mV = mV, sigma = sigma,
  alphab = alphab,
  alphat = alphat, alpham = alpham
) %>%
  mutate(parms.key = row_number())

# parameters with demographic noise ONLY
parms.grid.dem.noise <- parms.grid %>% 
  mutate(alphab = 0) %>% 
  mutate(alphat = 0) %>% 
  mutate(alpham = 0) %>%
  mutate(sigma = 0)

stoc.set.stats.dem.noise <- stats.stoc_fast(parms.grid.dem.noise, y0, tMax, nsim) %>%
  # Append parameter values to data frame
  right_join(., select(parms.grid.dem.noise, parms.key, sigma), by = "parms.key")
#calculate the probability of disease dying out out of 100 simulations
ext_prob[2,index] <- sum(stoc.set.stats.dem.noise$ext)/nsim

stoc.set.stats.demenv.noise <- stats.stoc_fast(parms.grid, y0, tMax, nsim) %>%
  # Append parameter values to data frame
  right_join(., select(parms.grid, parms.key, sigma), by = "parms.key")
#calculate the probability of disease dying out out of 100 simulations 
ext_prob[3,index] <- sum(stoc.set.stats.demenv.noise$ext)/nsim
}
ext_prob <- as.table(ext_prob)
ext_prob
```




```{r Pomp-trying, echo = FALSE}
f.stoc <- function(tMax, init_conds, parms) {
  with(as.list(c(parms, init_conds)), {
    dt <- 2^-8
    tseq <- seq(0, tMax, by = dt) # This ensures a fixed increment size determined by N
    N <- length(tseq)
    dW1 <- sqrt(dt) * rnorm(N, mean = 0, sd = 1) # H demographic stochasticity
    dW2 <- sqrt(dt) * rnorm(N, mean = 0, sd = 1) # V demographic stochasticity
    dW3 <- sqrt(dt) * rnorm(N, mean = 0, sd = 1) # Environmental stochasticity
    
    R <- 1
    Dt <- R * dt
    L <- N / R
    
    # Initial conditions (from init_conds)
    Htemp <- H
    Vtemp <- V
    
    Hout <- rep(0, L)
    Vout <- rep(0, L)
    
    tseq <- seq(0, tMax, length = L)
    
    for (i in 1:L) {
      
      W1inc <- sum(dW1[(R * (i - 1) + 1):(R * (i-1))])
      W2inc <- sum(dW2[(R * (i - 1) + 1):(R * (i-1))])
      W3inc <- sum(dW3[(R * (i - 1) + 1):(R * (i-1))])
      
      Htemp <- Htemp + (b * tHV * Vtemp * (NH - Htemp) / NH - gH * Htemp) * Dt +
        sqrt(b * tHV * Vtemp * (NH - Htemp) / NH + gH * Htemp) * W1inc +
        sigma * (alphab * Vtemp * tHV * (NH - Htemp) / NH) * W3inc
      
      Vtemp <- Vtemp + (b * tVH * Htemp * (NV - Vtemp) / NH - mV * Vtemp) * Dt +
        sqrt(b * tVH * Htemp * (NV - Vtemp) / NH + mV * Vtemp) * W2inc +
        sigma * (alphab * Htemp * tVH * (NV - Vtemp) / NH +
                   alphat * Htemp * b * (NV - Vtemp) / NH +
                   alpham * Vtemp
        ) * W3inc
      
      if (Htemp < 0 | is.nan(Htemp)) {
        Htemp <- 0
      }
      if (Vtemp < 0 | is.nan(Vtemp)) {
        Vtemp <- 0
      }
      
      Hout[i] <- Htemp
      Vout[i] <- Vtemp
    }
    
    return(data.frame(time = tseq, H = Hout, V = Vout))
  })
}

pomp_step <- Csnippet(
    "
  // C indexes at 0, for R users making things 1 bigger and start 
  // with index 1, i.e. leave trans[0] empty, same for rate[0]
  
  double rate[7];
  double trans[7];

  double foi;  // total force of infection
  double f;  // force of infection (symptomatic)
  double g;  // force of infection (asymptomatic)

  // Forces of Infection (foi):
  foi = exp(log_beta)*(I + exp(log_bL)*L + exp(log_bA)*A);   // total force of infection
  f = (1-a)*foi;                                            // foi from S to L
  g = a*foi;                                                // foi from S to A
  
  // Compute the transition rates
  // Transitions from S
  rate[1] = f;                                        //infection, movement from S to L
  rate[2] = g;                                        //infection, movement from S to A

  // Transitions from L
  rate[3] = exp(log_sigma);                           //movement from L to I
  rate[4] = exp(log_xi);                              //movement from L to R

  // Transitions from I
  rate[5] = exp(log_gammaI);                          //recovery from I to R

  // Transitions from A
  rate[6] = exp(log_gammaA)+exp(log_xi);              //movement from A to R

  // Compute the state transitions
  reulermultinom(2, S, &rate[1], dt, &trans[1]); //move from S to L (latent infection) or A (asympotmatic infection)
  reulermultinom(2, L, &rate[3], dt, &trans[3]); //move from L to I (symtom onset) or R (removal due to testing)
  reulermultinom(1, I, &rate[5], dt, &trans[5]); //move from I to R
  reulermultinom(1, A, &rate[6], dt, &trans[6]); //move from A to R (natural recovery + removal due to testing) 

  // Apply transitions to state variables
  S += - trans[1] - trans[2];
  L += trans[1] - trans[3] - trans[4];
  I += trans[3] - trans[5];
  A += trans[2] - trans[6];
  R += trans[4] + trans[5] + trans[6];
  C_report += trans[5];
  C_surveil += trans[4] + trans[6];
  "
)

simulate(
  times=0:tMax,t0=0,
  params=parms.vec,
  rinit=y0,
  
  rprocess=discrete_time(
    step.fun=Csnippet("
    double S = exp(-r*dt);
    double logeps = (sigma > 0.0) ? rnorm(0,sigma) : 0.0;
    X = pow(K,(1-S))*pow(X,S)*exp(logeps);"
    ),
    delta.t=dt
  ),
  ) -> Gompertz


y0 <- c(H = 0, V = 10) # These are numbers of infected, so better to initialize at smaller values
tMax <- 10 * 365 # 500
dt <- 0.01
tspan <- seq(0.0, tMax, dt)
parms.vec <- c(b = b, tHV = tHV, tVH = tVH, NH = NH, NV = NV, gH = gH, mV = mV)



university_model <- pomp(
  data = pseudo_data, 
  times = "time",
  t0 = 0,
  rinit = rinit,
  rprocess = euler(step.fun = pomp_step, delta.t = 1/20),
  statenames = varnames,
  paramnames = parnames, 
  obsnames = c("reports", "surveil"),
  accumvars = c("C_report", "C_surveil") 
)
simulate_covid <- function(allparvals, model, nsim=500){
  sims <- pomp::simulate(model, 
                         params=allparvals, 
                         nsim=nsim, format="data.frame", 
                         include.data=FALSE)
  
}
```


## Start of Plots from Julia
```{r}
jop <- read.csv("julia_outbreak_prob-1.csv")

```
```{r Fig: Boxplot of outbreak probability by sigma and R0, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} All one graph, based on 50 runs of 50 iterations'}

ggplot(data = jop , mapping = aes(x = as.factor(sigma), y = oprob_mean, color=as.factor(b))) +
  geom_boxplot()+ylim(0,1)
#+facet_wrap(~as.factor(b), ncol = 1, scales='free')
```
```{r Fig: Boxplot of outbreak probability by sigma and R0, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 50 runs of 50 iterations'}

ggplot(data = jop , mapping = aes(x = as.factor(sigma), y = oprob_mean)) +
  geom_boxplot()+facet_wrap(~as.factor(b), ncol = 2)+ylim(0,1)
```
```{r}
#results from 6/22 1000 runs of 100 iterations with R0 controlled by Tvh
jop1 <- read.csv("julia_outbreak_prob-2.csv")

```
```{r Fig: Boxplot of outbreak probability by sigma and R0, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 50 runs of 50 iterations'}

ggplot(data = jop1 , mapping = aes(x = as.factor(sigma), y = oprob_mean)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2)+ylim(0,1)
```







```{r}
#results from 6/22 1000 runs of 100 iterations with R0 controlled by Tvh
jop2 <- read.csv("julia_outbreak_prob-3.csv")

```
```{r Fig: Boxplot of outbreak probability by sigma and R0, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 50 runs of 50 iterations'}

ggplot(data = jop2 , mapping = aes(x = as.factor(sigma), y = oprob_mean)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2)+ylim(0,1)
```

```{r Fig: Boxplot of number of cases at the end of the simulation by sigma and R0, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 1000 runs of 100 iterations'}

ggplot(data = jop2 , mapping = aes(x = as.factor(sigma), y = num_cases)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2, scale='free')
```

```{r Fig: Boxplot of time that the outbreak died out by sigma and R0, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 1000 runs of 100 iterations'}

ggplot(data = jop2 , mapping = aes(x = as.factor(sigma), y = end_time)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2, scale='free')
```


```{r}
#results from 6/23 1000 runs of 100 iterations with R0 controlled by Tvh-parallel code stuff
jop_par <- read.csv("parallel_oprob-2.csv")

```
```{r Fig: Boxplot of outbreak probability by sigma and R0, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 50 runs of 50 iterations'}

ggplot(data = jop_par , mapping = aes(x = as.factor(sigma), y = oprob_mean)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2)+ylim(0,1)
```
```{r Fig: Boxplot of number of cases at the end of the simulation by sigma and R0, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 1000 runs of 100 iterations'}

ggplot(data = jop_par , mapping = aes(x = as.factor(sigma), y = num_cases)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2, scale='free')
```
```{r Fig: Boxplot of time that the outbreak died out by sigma and R0, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 1000 runs of 100 iterations'}

ggplot(data = jop_par , mapping = aes(x = as.factor(sigma), y = end_time)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2, scale='free')
```


```{r}
#results from 6/23 100 runs of 100 iterations with R0 controlled by Tvh-'old' code with output function
jop_try <- read.csv("julia_outbreak_prob-test.csv")

```
```{r Fig: Boxplot of outbreak probability by sigma and R0, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 50 runs of 50 iterations'}

ggplot(data = jop_try , mapping = aes(x = as.factor(sigma), y = oprob_mean)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2)+ylim(0,1)
```
```{r Fig: Boxplot of number of cases at the end of the simulation by sigma and R0, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 1000 runs of 100 iterations'}

ggplot(data = jop_try , mapping = aes(x = as.factor(sigma), y = num_cases)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2, scale='free')
```
```{r Fig: Boxplot of time that the outbreak died out by sigma and R0, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 1000 runs of 100 iterations'}

ggplot(data = jop_try , mapping = aes(x = as.factor(sigma), y = end_time)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2, scale='free')
```
```{r}
#results from 100 runs of 100 iterations with alpha_B turned off
jop_aB_off <- read.csv("julia_oprob_aB-off.csv")

```
```{r Fig: Boxplot of outbreak probability by sigma and R0 with alpha_B turned off, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 50 runs of 50 iterations'}

ggplot(data = jop_aB_off , mapping = aes(x = as.factor(sigma), y = oprob_mean)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2)+ylim(0,1)
```
```{r Fig: Boxplot of number of cases at the end of the simulation by sigma and R0 with alpha_B turned off, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 1000 runs of 100 iterations'}

ggplot(data = jop_aB_off , mapping = aes(x = as.factor(sigma), y = num_cases)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2, scale='free')
```
```{r Fig: Boxplot of time that the outbreak died out by sigma and R0 with alpha_B turned off, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 1000 runs of 100 iterations'}

ggplot(data = jop_aB_off , mapping = aes(x = as.factor(sigma), y = end_time)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2, scale='free')
```


```{r}
#results from 100 runs of 100 iterations with alpha_T turned off
jop_aT_off <- read.csv("julia_oprob_aT-off.csv")

```
```{r Fig: Boxplot of outbreak probability by sigma and R0 with alpha_T turned off, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 50 runs of 50 iterations'}

ggplot(data = jop_aT_off , mapping = aes(x = as.factor(sigma), y = oprob_mean)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2)+ylim(0,1)
```
```{r Fig: Boxplot of number of cases at the end of the simulation by sigma and R0 with alpha_T turned off, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 1000 runs of 100 iterations'}

ggplot(data = jop_aT_off , mapping = aes(x = as.factor(sigma), y = num_cases)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2, scale='free')
```
```{r Fig: Boxplot of time that the outbreak died out by sigma and R0 with alpha_T turned off, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 1000 runs of 100 iterations'}

ggplot(data = jop_aT_off , mapping = aes(x = as.factor(sigma), y = end_time)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2, scale='free')
```


```{r}
#results from 100 runs of 100 iterations with alpha_M turned off
jop_aM_off <- read.csv("julia_oprob_aM-off.csv")

```
```{r Fig: Boxplot of outbreak probability by sigma and R0 with alpha_M turned off, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 50 runs of 50 iterations'}

ggplot(data = jop_aM_off , mapping = aes(x = as.factor(sigma), y = oprob_mean)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2)+ylim(0,1)
```
```{r Fig: Boxplot of number of cases at the end of the simulation by sigma and R0 with alpha_M turned off, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 1000 runs of 100 iterations'}

ggplot(data = jop_aM_off , mapping = aes(x = as.factor(sigma), y = num_cases)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2, scale='free')
```
```{r Fig: Boxplot of time that the outbreak died out by sigma and R0 with alpha_M turned off, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 1000 runs of 100 iterations'}

ggplot(data = jop_aM_off , mapping = aes(x = as.factor(sigma), y = end_time)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2, scale='free')
```
```{r}
#results from 100 runs of 100 iterations with alpha_M turned on
jop_aB_on <- read.csv("julia_oprob_aB-on.csv")

```
```{r Fig: Boxplot of outbreak probability by sigma and R0 with alpha_B turned on, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 50 runs of 50 iterations'}

ggplot(data = jop_aB_on , mapping = aes(x = as.factor(sigma), y = oprob_mean)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2)+ylim(0,1)
```
```{r Fig: Boxplot of number of cases at the end of the simulation by sigma and R0 with alpha_B turned on, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 1000 runs of 100 iterations'}

ggplot(data = jop_aB_on , mapping = aes(x = as.factor(sigma), y = num_cases)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2, scale='free')
```
```{r Fig: Boxplot of time that the outbreak died out by sigma and R0 with alpha_B turned on, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 1000 runs of 100 iterations'}

ggplot(data = jop_aB_on , mapping = aes(x = as.factor(sigma), y = end_time)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2, scale='free')
```


```{r}
#results from 100 runs of 100 iterations with alpha_M turned on
jop_aT_on <- read.csv("julia_oprob_aM-on.csv")

```
```{r Fig: Boxplot of outbreak probability by sigma and R0 with alpha_T turned on, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 50 runs of 50 iterations'}

ggplot(data = jop_aT_on , mapping = aes(x = as.factor(sigma), y = oprob_mean)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2)+ylim(0,1)
```
```{r Fig: Boxplot of number of cases at the end of the simulation by sigma and R0 with alpha_T turned on, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 1000 runs of 100 iterations'}

ggplot(data = jop_aT_on , mapping = aes(x = as.factor(sigma), y = num_cases)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2, scale='free')
```
```{r Fig: Boxplot of time that the outbreak died out by sigma and R0 with alpha_T turned on, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 1000 runs of 100 iterations'}

ggplot(data = jop_aT_on , mapping = aes(x = as.factor(sigma), y = end_time)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2, scale='free')
```


```{r}
#results from 100 runs of 100 iterations with alpha_M turned on
jop_aM_on <- read.csv("julia_oprob_aM-on.csv")

```
```{r Fig: Boxplot of outbreak probability by sigma and R0 with alpha_M turned on, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 50 runs of 50 iterations'}

ggplot(data = jop_aM_on , mapping = aes(x = as.factor(sigma), y = oprob_mean)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2)+ylim(0,1)
```
```{r Fig: Boxplot of number of cases at the end of the simulation by sigma and R0 with alpha_M turned on, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 1000 runs of 100 iterations'}

ggplot(data = jop_aM_on , mapping = aes(x = as.factor(sigma), y = num_cases)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2, scale='free')
```
```{r Fig: Boxplot of time that the outbreak died out by sigma and R0 with alpha_M turned on, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 1000 runs of 100 iterations'}

ggplot(data = jop_aM_on , mapping = aes(x = as.factor(sigma), y = end_time)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2, scale='free')
```
```{r}
#results from 100 runs of 100 iterations with alpha_M turned on
pt2 <- read.csv("parallel_oprob-test2.csv")

```
```{r Fig: Boxplot of outbreak probability by sigma and R0 with alpha_M turned on, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 50 runs of 50 iterations'}

ggplot(data = pt2 , mapping = aes(x = as.factor(sigma), y = oprob_mean)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2)+ylim(0,1)
```
```{r Fig: Boxplot of number of cases at the end of the simulation by sigma and R0 with alpha_M turned on, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 1000 runs of 100 iterations'}

ggplot(data = pt2 , mapping = aes(x = as.factor(sigma), y = num_cases)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2, scale='free')
```
```{r Fig: Boxplot of time that the outbreak died out by sigma and R0 with alpha_M turned on, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} faceted by R0, based on 1000 runs of 100 iterations'}

ggplot(data = pt2 , mapping = aes(x = as.factor(sigma), y = end_time)) +
  geom_boxplot()+facet_wrap(~as.factor(Tvh), ncol = 2, scale='free')
```

#Publication Quality Figure Start
```{r}
#results from 1000 runs of 100 iterations 
jop_results <- read.csv("julia_oprob_results1.csv")
jop_results$R0 <- jop_results$Tvh
jop_results$R0 <- replace(jop_results$R0, jop_results$R0==0.0125, 'R0=0.75')
jop_results$R0  <- replace(jop_results$R0, jop_results$R0==0.02005556, 'R0=0.95')
jop_results$R0  <- replace(jop_results$R0, jop_results$R0==0.0245, 'R0=1.05')
jop_results$R0  <- replace(jop_results$R0, jop_results$R0==0.35555556, 'R0=4')

```
```{r Fig: Boxplot of outbreak probability by sigma and R0, dev='png', out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEproboutbreak} Probability of an outbreak by sigma and R0 based on 1000 runs of 100 iterations.'}

ggplot(data = jop_results , mapping = aes(x = as.factor(sigma), y = oprob_mean)) +
  geom_boxplot()+facet_wrap(~as.factor(R0), ncol = 1)+ylim(0,1)+theme_cowplot()+ylab('Probability of an outbreak')+
  xlab('sigma')

p1 = ggplot(data = jop_results , mapping = aes(x = as.factor(sigma), y = oprob_mean)) +
  geom_boxplot()+facet_wrap(~as.factor(R0), ncol = 1)+ylim(0,1)+theme_cowplot()+ylab('Probability of an outbreak')+
  xlab('sigma')

ggsave('oprob4.png')
```
```{r Fig: Boxplot of outbreak probability by sigma and R0 in 1 plot, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEproboutbreak} Probability of an outbreak by sigma and R0 based on 1000 runs of 100 iterations.'}

ggplot(data = jop_results , mapping = aes(x = as.factor(sigma), y = oprob_mean,  color=R0)) +
  geom_boxplot()+ylim(0,1)+theme_cowplot()+ylab('Probability of an outbreak')+
  xlab('sigma')
ggsave('oprob1.png')
```

```{r Fig: Boxplot of number of cases at the end of the simulation by sigma and R0, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEnuminfected} Number of hosts infected at the end of simulation (only including simulations where the outbreak did not die out) by sigma and R0 based on 1000 runs of 100 iterations.'}

ggplot(data = jop_results[jop_results$oprob_mean !=0,], mapping = aes(x = as.factor(sigma), y = num_cases)) +
  geom_boxplot()+facet_wrap(~as.factor(R0), ncol = 1)+theme_cowplot()+ylab('Average number of hosts infected')+
  xlab('sigma')
ggsave('numcases4.png')
```
```{r Fig: Boxplot of number of hosts infected at the end by sigma and R0 in 1 plot, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEproboutbreak} Number of hosts infected at the end of simulation (only including simulations where the outbreak did not die out) by sigma and R0 based on 1000 runs of 100 iterations.'}

ggplot(data = jop_results[jop_results$oprob_mean !=0,] , mapping = aes(x = as.factor(sigma), y = num_cases,  color=R0)) +
  geom_boxplot()+theme_cowplot()+ylab('Average number of hosts infected')+
  xlab('sigma')
ggsave('numcases1.png')
```


```{r Fig: Boxplot of time that the outbreak died out by sigma and R0, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEendtime} Time that the outbreak died out (only including simulations where the outbreak did die out) by sigma and R0 based on 1000 runs of 100 iterations.'}

ggplot(data = jop_results[jop_results$oprob_mean !=1,] , mapping = aes(x = as.factor(sigma), y = end_time)) +
  geom_boxplot()+facet_wrap(~as.factor(R0), ncol = 1)+theme_cowplot()+ylab('Average time outbreak dies out')+
  xlab('sigma')
ggsave('endtime4.png')
```
```{r Fig: Boxplot of time that the outbreak died out by sigma and R0 in 1 plot, out.width='100%', fig.align='center', fig.cap='\\label{fig:SDEendtime} Time that the outbreak died out (only including simulations where the outbreak did die out) by sigma and R0 based on 1000 runs of 100 iterations.'}

ggplot(data = jop_results[jop_results$oprob_mean !=1,] , mapping = aes(x = as.factor(sigma), y = end_time,  color=R0)) +
  geom_boxplot()+theme_cowplot()+ylab('Average time outbreak dies out')+
  xlab('sigma')
ggsave('endtime1.png')
```
# Mean values plotting
```{r}
jop <- read.csv("julia_mean_test.csv")
```
```{r}
library(tidyverse)
jop_eprob <-gather(jop, key = "state", value = "number", prob_end_mean, prob_end_25, prob_end_75)
```
```{r}
ggplot(jop_eprob[jop_eprob$state=='prob_end_mean',], aes(x=sigma, y=number, group=Tvh))+
  geom_line(aes(color=as.factor(Tvh))) + geom_point(data=jop_eprob[jop_eprob$state!='prob_end_mean',], aes(x=sigma, y=number, group=Tvh, color=as.factor(Tvh)))
```

```{r}
jop %>% gather( key = "state", value = "number", prob_end_mean, prob_end_25, prob_end_75) %>%
  {ggplot(data=subset(., state == "prob_end_mean"))+
  geom_line(aes(x=sigma, y=number, group=Tvh,color=as.factor(Tvh))) + geom_point(data=subset(., state != "prob_end_mean"), aes(x=sigma, y=number, group=Tvh, color=as.factor(Tvh)))+scale_color_viridis(discrete=TRUE)}
```
```{r}
ggplot(jop, aes(x=sigma, y=prob_end_mean))+geom_line(aes(color=as.factor(Tvh)))+geom_ribbon(aes(ymin=prob_end_25, ymax=prob_end_75, color=as.factor(Tvh),fill=as.factor(Tvh), alpha=0.3))+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)
```
```{r}
ggplot(jop, aes(x=sigma, y=prob_end_mean))+geom_line(aes(color=as.factor(Tvh)))+geom_linerange(aes(ymin=prob_end_25, ymax=prob_end_75, color=as.factor(Tvh)))+scale_color_viridis(discrete=TRUE)
```

```{r}
ggplot(jop, aes(x=sigma, y=prob_out_mean))+geom_line(aes(color=as.factor(Tvh)))+geom_ribbon(aes(ymin=prob_out_25, ymax=prob_out_75, color=as.factor(Tvh),fill=as.factor(Tvh), alpha=0.3))+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)
```


```{r}
jop %>% gather( key = "state", value = "number", prob_out_mean, prob_out_25, prob_out_75) %>%
  {ggplot(data=subset(., state == "prob_out_mean"))+
  geom_line(aes(x=sigma, y=number, group=Tvh,color=as.factor(Tvh))) + geom_point(data=subset(., state != "prob_out_mean"), aes(x=sigma, y=number, group=Tvh, color=as.factor(Tvh)))}
```
```{r}
jop %>% gather( key = "state", value = "number", end_time_mean, end_time_25, end_time_75) %>%
  {ggplot(data=subset(., state == "end_time_mean"))+
  geom_line(aes(x=sigma, y=number, group=Tvh,color=as.factor(Tvh))) + geom_point(data=subset(., state != "end_time_mean"), aes(x=sigma, y=number, group=Tvh, color=as.factor(Tvh)))}
```
```{r}
ggplot(jop, aes(x=end_time_mean, y=max_cases_mean))+geom_point(aes(color=as.factor(sigma), shape=as.factor(Tvh)))+
  geom_path(aes(color=as.factor(sigma), ))+scale_color_viridis(discrete=TRUE)
```

```{r}
ggplot(jop, aes(x=end_time_mean, y=max_cases_mean))+geom_point(aes(color=as.factor(sigma), shape=as.factor(Tvh)))+
scale_color_viridis(discrete=TRUE)
```

```{r}
ggplot(jop, aes(x=num_cases_mean, y=max_cases_mean))+geom_point(aes(color=as.factor(sigma), shape=as.factor(Tvh)))+
  geom_path(aes(color=as.factor(sigma), ))+scale_color_viridis(discrete=TRUE)+theme(legend.position = "bottom")
```
```{r}
jop_1 <- read.csv("julia_mean_test_1.csv")
```
```{r}
ggplot(jop_1, aes(x=sigma, y=prob_end_mean))+geom_line(aes(color=as.factor(Tvh)))+geom_ribbon(aes(ymin=prob_end_25, ymax=prob_end_75, color=as.factor(Tvh),fill=as.factor(Tvh), alpha=0.3))+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)
```
```{r}
ggplot(jop_1, aes(x=sigma, y=prob_out10_mean))+geom_line(aes(color=as.factor(Tvh)))+geom_ribbon(aes(ymin=prob_out10_25, ymax=prob_out10_75, color=as.factor(Tvh),fill=as.factor(Tvh), alpha=0.3))+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)
```
```{r}
ggplot(jop_1, aes(x=sigma, y=prob_out100_mean))+geom_line(aes(color=as.factor(Tvh)))+geom_ribbon(aes(ymin=prob_out100_25, ymax=prob_out100_75, color=as.factor(Tvh),fill=as.factor(Tvh), alpha=0.3))+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)
```
```{r}
ggplot(jop_1, aes(x=sigma, y=max_cases_all_mean))+geom_line(aes(color=as.factor(Tvh)))+geom_ribbon(aes(ymin=max_cases_all_25, ymax=max_cases_all_75, color=as.factor(Tvh),fill=as.factor(Tvh), alpha=0.3))+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)
```
```{r}
ggplot(jop_1, aes(x=sigma, y=end_time_mean))+geom_line(aes(color=as.factor(Tvh)))+geom_ribbon(aes(ymin=end_time_25, ymax=end_time_75, color=as.factor(Tvh),fill=as.factor(Tvh), alpha=0.3))+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)
```
```{r}
ggplot(jop_1, aes(x=end_time_mean, y=max_cases_out_mean))+geom_point(aes(color=as.factor(sigma), shape=as.factor(Tvh)))+scale_color_viridis(discrete=TRUE)+scale_shape_manual(values=c(0,1,2,3,4,7,8))
```
```{r}
jop_1$R0_cond <- jop_1$Tvh
jop_1$R0_cond <- replace(jop_1$R0_cond, jop_1$R0_cond==0.0125, '<1')
jop_1$R0_cond <- replace(jop_1$R0_cond, jop_1$R0_cond==0.02005556, '<1')
jop_1$R0_cond <- replace(jop_1$R0_cond, jop_1$R0_cond!='<1', '>1')
jop_1$sig_cond <- jop_1$sigma
jop_1$sig_cond <- replace(jop_1$sig_cond, jop_1$sig_cond==0| jop_1$sig_cond==0.02| jop_1$sig_cond==0.04| jop_1$sig_cond==0.06| jop_1$sig_cond==0.08|jop_1$sig_cond==0.1| jop_1$sig_cond==0.12, 'low')
jop_1$sig_cond <- replace(jop_1$sig_cond, jop_1$sig_cond==0.14| jop_1$sig_cond==0.16| jop_1$sig_cond==0.18| jop_1$sig_cond==0.2| jop_1$sig_cond==0.22| jop_1$sig_cond==0.24| jop_1$sig_cond==0.26, 'med')
jop_1$sig_cond <- replace(jop_1$sig_cond, jop_1$sig_cond==0.28| jop_1$sig_cond==0.3| jop_1$sig_cond==0.32| jop_1$sig_cond==0.34| jop_1$sig_cond==0.36| jop_1$sig_cond==0.38| jop_1$sig_cond==0.4, 'high')
```
```{r}
ggplot(jop_1, aes(x=end_time_mean, y=max_cases_out_mean))+geom_point(aes(color=as.factor(sig_cond), shape=as.factor(R0_cond)))+scale_shape_manual(values=c(0,1))+
  geom_hline(yintercept = median(na.omit(jop_1$max_cases_out_mean)))+geom_vline(xintercept = median(na.omit(jop_1$end_time_mean)))+theme_bw()
```



```{r}
ggplot(jop_1, aes(x=num_cases_mean, y=max_cases_end_mean))+geom_point(aes(color=as.factor(sigma), shape=as.factor(Tvh)))+scale_color_viridis(discrete=TRUE)+scale_shape_manual(values=c(0,1,2,3,4,7,8))
```
```{r}
ggplot(jop_1, aes(x=sigma, y=max_cases_end_mean))+geom_line(aes(color=as.factor(Tvh)))+geom_point(aes(x=sigma, y=max_cases_out_mean, color=as.factor(Tvh)))+scale_color_viridis(discrete=TRUE)
```
```{r}
jop_2 <- read.csv("julia_mean_test_2.csv")
```
```{r}
ggplot(jop_2, aes(x=sigma, y=prob_end_mean))+geom_line(aes(color=as.factor(Tvh)))+geom_ribbon(aes(ymin=prob_end_25, ymax=prob_end_75, color=as.factor(Tvh),fill=as.factor(Tvh), alpha=0.3))+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)
```
```{r}
ggplot(jop_2, aes(x=sigma, y=prob_out50_mean))+geom_line(aes(color=as.factor(Tvh)))+geom_ribbon(aes(ymin=prob_out50_25, ymax=prob_out50_75, color=as.factor(Tvh),fill=as.factor(Tvh), alpha=0.3))+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)
```
```{r}
ggplot(jop_1, aes(x=sigma, y=prob_out100_mean))+geom_line(aes(color=as.factor(Tvh)))+geom_ribbon(aes(ymin=prob_out100_25, ymax=prob_out100_75, color=as.factor(Tvh),fill=as.factor(Tvh), alpha=0.3))+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)
```
```{r}
jop_3 <- read.csv("julia_mean_test_3.csv")
#with 10 instead of 100 mosquitos to start in these 100,000 mosquito 10,000 host systems
```
```{r}
ggplot(jop_3, aes(x=sigma, y=prob_end_mean))+geom_line(aes(color=as.factor(Tvh)))+geom_ribbon(aes(ymin=prob_end_25, ymax=prob_end_75, color=as.factor(Tvh),fill=as.factor(Tvh)), alpha=0.3)+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)
```
```{r}
ggplot(jop_3, aes(x=sigma, y=prob_out50_mean))+geom_line(aes(color=as.factor(Tvh)))+geom_ribbon(aes(ymin=prob_out50_25, ymax=prob_out50_75, color=as.factor(Tvh),fill=as.factor(Tvh)), alpha=0.3)+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)
```
```{r}
ggplot(jop_3, aes(x=sigma, y=prob_out100_mean))+geom_line(aes(color=as.factor(Tvh)))+geom_ribbon(aes(ymin=prob_out100_25, ymax=prob_out100_75, color=as.factor(Tvh),fill=as.factor(Tvh)), alpha=0.3)+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)
```
```{r}
jop_3$R0_cond <- jop_3$Tvh
jop_3$R0_cond <- replace(jop_3$R0_cond, jop_3$R0_cond==0.0125, '<1')
jop_3$R0_cond <- replace(jop_3$R0_cond, jop_3$R0_cond==0.02005556, '<1')
jop_3$R0_cond <- replace(jop_3$R0_cond, jop_3$R0_cond!='<1', '>1')
jop_3$sig_cond <- jop_3$sigma
jop_3$sig_cond <- replace(jop_3$sig_cond, jop_3$sig_cond==0| jop_3$sig_cond==0.02| jop_3$sig_cond==0.04| jop_3$sig_cond==0.06| jop_3$sig_cond==0.08|jop_3$sig_cond==0.1| jop_3$sig_cond==0.12, 'low')
jop_3$sig_cond <- replace(jop_3$sig_cond, jop_3$sig_cond==0.14| jop_3$sig_cond==0.16| jop_3$sig_cond==0.18| jop_3$sig_cond==0.2| jop_3$sig_cond==0.22| jop_3$sig_cond==0.24| jop_3$sig_cond==0.26, 'med')
jop_3$sig_cond <- replace(jop_3$sig_cond, jop_3$sig_cond==0.28| jop_3$sig_cond==0.3| jop_3$sig_cond==0.32| jop_3$sig_cond==0.34| jop_3$sig_cond==0.36| jop_3$sig_cond==0.38| jop_3$sig_cond==0.4, 'high')
```
```{r}
ggplot(jop_3, aes(x=end_time_mean, y=max_cases_out_mean))+geom_point(aes(color=as.factor(sig_cond), shape=as.factor(R0_cond)))+scale_shape_manual(values=c(0,1))+
  geom_hline(yintercept = median(na.omit(jop_3$max_cases_out_mean)))+geom_vline(xintercept = median(na.omit(jop_3$end_time_mean)))+theme_bw()
```
```{r}
ggplot(jop_3, aes(x=sigma, y=end_time_mean))+geom_line(aes(color=as.factor(Tvh)))+geom_ribbon(aes(ymin=end_time_25, ymax=end_time_75, color=as.factor(Tvh),fill=as.factor(Tvh)), alpha=0.3)+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)
```
```{r}
jop_4 <- read.csv("julia_mean_test_4.csv")
#with 10 instead of 100 mosquitos to start in these 100,000 mosquito 10,000 host systems
```
```{r}
ggplot(jop_4, aes(x=sigma, y=prob_out10_mean))+geom_line(aes(color=as.factor(Tvh)))+geom_ribbon(aes(ymin=prob_out10_25, ymax=prob_out10_75, color=as.factor(Tvh),fill=as.factor(Tvh)), alpha=0.3)+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)
```
```{r}
ggplot(jop_4, aes(x=sigma, y=prob_out100_mean))+geom_line(aes(color=as.factor(Tvh)))+geom_ribbon(aes(ymin=prob_out100_25, ymax=prob_out100_75, color=as.factor(Tvh),fill=as.factor(Tvh)), alpha=0.3)+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)
```
```{r}
jop_5 <- read.csv("julia_mean_test_5.csv")
#with 10 instead of 100 mosquitos to start in these 100,000 mosquito 10,000 host systems
```
```{r}
ggplot(jop_5, aes(x=sigma, y=prob_end_mean))+geom_line(aes(color=as.factor(Tvh)))+geom_point(aes(color=as.factor(Tvh)))+geom_ribbon(aes(ymin=prob_end_25, ymax=prob_end_75, color=as.factor(Tvh),fill=as.factor(Tvh)), alpha=0.3)+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)
```
```{r}
ggplot(jop_5, aes(x=sigma, y=prob_out10_mean))+geom_line(aes(color=as.factor(Tvh)))+geom_point(aes(color=as.factor(Tvh)))+geom_ribbon(aes(ymin=prob_out10_25, ymax=prob_out10_75, color=as.factor(Tvh),fill=as.factor(Tvh)), alpha=0.3)+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)
```
```{r}
ggplot(jop_5, aes(x=sigma, y=prob_out100_mean))+geom_line(aes(color=as.factor(Tvh)))+geom_point(aes(color=as.factor(Tvh)))+geom_ribbon(aes(ymin=prob_out100_25, ymax=prob_out100_75, color=as.factor(Tvh),fill=as.factor(Tvh)), alpha=0.3)+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)
```
```{r}
ggplot(jop_5, aes(x=sigma, y=end_time_mean))+geom_line(aes(color=as.factor(Tvh)))+geom_point(aes(color=as.factor(Tvh)))+geom_ribbon(aes(ymin=end_time_25, ymax=end_time_75, color=as.factor(Tvh),fill=as.factor(Tvh)), alpha=0.3)+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)
```
```{r}
jop_5$R0_cond <- jop_5$Tvh
jop_5$R0_cond <- replace(jop_5$R0_cond, jop_5$R0_cond==0.0125, '<1')
jop_5$R0_cond <- replace(jop_5$R0_cond, jop_5$R0_cond==0.02005556, '<1')
jop_5$R0_cond <- replace(jop_5$R0_cond, jop_5$R0_cond!='<1', '>1')
jop_5$sig_cond <- jop_5$sigma
jop_5$sig_cond <- replace(jop_5$sig_cond, jop_5$sig_cond==0| jop_5$sig_cond==0.02| jop_5$sig_cond==0.04| jop_5$sig_cond==0.06| jop_5$sig_cond==0.08|jop_5$sig_cond==0.1| jop_5$sig_cond==0.12, 'low')
jop_5$sig_cond <- replace(jop_5$sig_cond, jop_5$sig_cond==0.14| jop_5$sig_cond==0.16| jop_5$sig_cond==0.18| jop_5$sig_cond==0.2| jop_5$sig_cond==0.22| jop_5$sig_cond==0.24| jop_5$sig_cond==0.26, 'med')
jop_5$sig_cond <- replace(jop_5$sig_cond, jop_5$sig_cond==0.28| jop_5$sig_cond==0.3| jop_5$sig_cond==0.32| jop_5$sig_cond==0.34| jop_5$sig_cond==0.36| jop_5$sig_cond==0.38| jop_5$sig_cond==0.4, 'high')
```

```{r}
ggplot(jop_5, aes(y=end_time_mean, x=time_max_mean))+geom_point(aes(color=as.factor(sig_cond), shape=as.factor(R0_cond)))+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)
```

```{r}
ggplot(jop_5, aes(y=max_cases_all_mean, x=time_max_mean))+geom_point(aes(color=as.factor(sig_cond), shape=as.factor(R0_cond)))+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)+
```
```{r}
ggplot(jop_5, aes(y=max_cases_all_mean, x=end_time_mean))+geom_point(aes(color=as.factor(sig_cond), shape=as.factor(R0_cond)))+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)+geom_hline(yintercept = median(na.omit(jop_5$max_cases_all_mean)))+geom_vline(xintercept = median(na.omit(jop_5$end_time_mean)))
```
```{r}
ggplot(jop_5, aes(y=max_cases_all_mean, x=num_cases_mean))+geom_point(aes(color=as.factor(sig_cond), shape=as.factor(R0_cond)))+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)
```

```{r}
ggplot(jop_5, aes(x=sigma, y=max_cases_all_mean))+geom_line(aes(color=as.factor(Tvh)))+geom_point(aes(color=as.factor(Tvh)))+geom_ribbon(aes(ymin=max_cases_all_25, ymax=max_cases_all_75, color=as.factor(Tvh),fill=as.factor(Tvh)), alpha=0.3)+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)
```
```{r}
ggplot(jop_5, aes(x=sigma, y=time_max_mean))+geom_line(aes(color=as.factor(Tvh)))+geom_point(aes(color=as.factor(Tvh)))+geom_ribbon(aes(ymin=time_max_25, ymax=time_max_75, color=as.factor(Tvh),fill=as.factor(Tvh)), alpha=0.3)+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)
```
```{r}
ggplot(jop_5, aes(x=sigma, y=num_cases_mean))+geom_line(aes(color=as.factor(Tvh)))+geom_point(aes(color=as.factor(Tvh)))+geom_ribbon(aes(ymin=num_cases_25, ymax=num_cases_75, color=as.factor(Tvh),fill=as.factor(Tvh)), alpha=0.3)+scale_color_viridis(discrete=TRUE)+scale_fill_viridis(discrete=TRUE)
```
```{r}
ggplot(jop_5, aes(x=sigma, y=max_cases_end_mean))+geom_line(aes(color=as.factor(Tvh)))+geom_point(aes(x=sigma, y=max_cases_out_mean, color=as.factor(Tvh)))+scale_color_viridis(discrete=TRUE)
```







